// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: transit.proto

/*
Package transit is a generated protocol buffer package.

It is generated from these files:
	transit.proto

It has these top-level messages:
	Pong
	Published
	Publication
	Entry
	Subscription
	Notification
	Acknowledgement
	Sub
	Acked
	ApplyCommands
	Command
	Server
	BoxItem
	Snapshot
	Box
	Update
	Success
	String
	Strings
	StringMap
	Void
*/
package transit

import proto "github.com/gogo/protobuf/proto"
import golang_proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/golang/protobuf/ptypes/any"
import _ "github.com/gogo/googleapis/google/api"
import _ "github.com/grpc-ecosystem/grpc-gateway/protoc-gen-swagger/options"
import _ "github.com/gogo/protobuf/gogoproto"
import _ "github.com/mwitkow/go-proto-validators"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type DistributionStrategy int32

const (
	// Default uses the default strategy of the group.
	DistributionStrategy_Default DistributionStrategy = 0
	// Arbitrary distribution means that any processor may get any message.
	DistributionStrategy_Arbitrary DistributionStrategy = 1
	// Requested distribution limits messages to processors that have requested type of the specific lot.
	DistributionStrategy_Requested DistributionStrategy = 2
	// Assigned distribution will assign unrequested lots to processors based on load (Arbitrary âˆ§ Requested).
	DistributionStrategy_Assigned DistributionStrategy = 3
)

var DistributionStrategy_name = map[int32]string{
	0: "Default",
	1: "Arbitrary",
	2: "Requested",
	3: "Assigned",
}
var DistributionStrategy_value = map[string]int32{
	"Default":   0,
	"Arbitrary": 1,
	"Requested": 2,
	"Assigned":  3,
}

func (x DistributionStrategy) String() string {
	return proto.EnumName(DistributionStrategy_name, int32(x))
}
func (DistributionStrategy) EnumDescriptor() ([]byte, []int) { return fileDescriptorTransit, []int{0} }

type DeliveryStrategy int32

const (
	// Unspecified uses the current strategy (default = Concurrent).
	DeliveryStrategy_Unspecified DeliveryStrategy = 0
	// Concurrent messages are not treated specially.
	DeliveryStrategy_Concurrent DeliveryStrategy = 1
	// Drop means if there's currently one waiting, don't bother with this one and drop it.
	DeliveryStrategy_Drop DeliveryStrategy = 2
	// Replace means if there's currently one waiting, replace it with this one.
	DeliveryStrategy_Replace DeliveryStrategy = 3
	// Ignore means if there's currently one waiting, delete it and place this one at the back of the queue.
	DeliveryStrategy_Ignore DeliveryStrategy = 4
	// A Serial message will not begin processing a duplicate identity message at the same time as another.
	DeliveryStrategy_Serial DeliveryStrategy = 5
)

var DeliveryStrategy_name = map[int32]string{
	0: "Unspecified",
	1: "Concurrent",
	2: "Drop",
	3: "Replace",
	4: "Ignore",
	5: "Serial",
}
var DeliveryStrategy_value = map[string]int32{
	"Unspecified": 0,
	"Concurrent":  1,
	"Drop":        2,
	"Replace":     3,
	"Ignore":      4,
	"Serial":      5,
}

func (x DeliveryStrategy) String() string {
	return proto.EnumName(DeliveryStrategy_name, int32(x))
}
func (DeliveryStrategy) EnumDescriptor() ([]byte, []int) { return fileDescriptorTransit, []int{1} }

// Concern is the level of write concern you wish to achieve when publishing.
type Concern int32

const (
	// None indicates you just want to be delivered and don't care about it at all, you won't get back an ID.
	Concern_None Concern = 0
	// Received waits for the message to be received by the server and gets the ID back.
	Concern_Received Concern = 1
	// Delivered waits for the message to be delivered to the server and inserted into all inboxes.
	Concern_Delivered Concern = 2
	// Confirmed means that the message has been delivered and is confirmed in the queues of existing slave servers.
	// This is not currently implemented and is the same as Delivered currently.
	Concern_Confirmed Concern = 3
	// Processed requires that the server has delivered the entry to all subscribers and they in turn have ACKed it.
	Concern_Processed Concern = 4
)

var Concern_name = map[int32]string{
	0: "None",
	1: "Received",
	2: "Delivered",
	3: "Confirmed",
	4: "Processed",
}
var Concern_value = map[string]int32{
	"None":      0,
	"Received":  1,
	"Delivered": 2,
	"Confirmed": 3,
	"Processed": 4,
}

func (x Concern) String() string {
	return proto.EnumName(Concern_name, int32(x))
}
func (Concern) EnumDescriptor() ([]byte, []int) { return fileDescriptorTransit, []int{2} }

// Pong is used by Ping to check the server is alive and who the current leader is.
type Pong struct {
	// ID is an incrementing ID indicating the most recently allocated Entry ID.
	ID uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// Leader is the current cluster leader to whom all commands other than Ping must be sent.
	Leader string `protobuf:"bytes,2,opt,name=leader,proto3" json:"leader,omitempty"`
	// Leading is true if the pinged server is the leader.
	Leading bool `protobuf:"varint,3,opt,name=leading,proto3" json:"leading,omitempty"`
}

func (m *Pong) Reset()                    { *m = Pong{} }
func (m *Pong) String() string            { return proto.CompactTextString(m) }
func (*Pong) ProtoMessage()               {}
func (*Pong) Descriptor() ([]byte, []int) { return fileDescriptorTransit, []int{0} }

func (m *Pong) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Pong) GetLeader() string {
	if m != nil {
		return m.Leader
	}
	return ""
}

func (m *Pong) GetLeading() bool {
	if m != nil {
		return m.Leading
	}
	return false
}

// Publication is returned from a call to Publish.
type Published struct {
	// ID is the internally assigned ID for your submitted Entry.
	ID uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// Concern is the reached write concern level at the time of the published message being created.
	// Note: The returned write concern may not be the same as your requested concern.
	Concern Concern `protobuf:"varint,10,opt,name=concern,proto3,enum=Concern" json:"concern,omitempty"`
}

func (m *Published) Reset()                    { *m = Published{} }
func (m *Published) String() string            { return proto.CompactTextString(m) }
func (*Published) ProtoMessage()               {}
func (*Published) Descriptor() ([]byte, []int) { return fileDescriptorTransit, []int{1} }

func (m *Published) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Published) GetConcern() Concern {
	if m != nil {
		return m.Concern
	}
	return Concern_None
}

// Publication is sent to a call to Publish.
type Publication struct {
	// Entry is the entry that is being added to the queue.
	Entry *Entry `protobuf:"bytes,1,opt,name=entry" json:"entry,omitempty"`
	// Concern is the write concern of the publisher.
	Concern Concern `protobuf:"varint,10,opt,name=concern,proto3,enum=Concern" json:"concern,omitempty"`
	// Timeout is how many milliseconds the publisher is willing to wait for it's write concern.
	// If the timeout expires, the publisher will get back a Published with the reached write concern.
	// If timeout is zero, the thread will wait forever until the desired state is reached, the client disconnects
	// or the server shuts down.
	Timeout uint64 `protobuf:"varint,11,opt,name=timeout,proto3" json:"timeout,omitempty"`
}

func (m *Publication) Reset()                    { *m = Publication{} }
func (m *Publication) String() string            { return proto.CompactTextString(m) }
func (*Publication) ProtoMessage()               {}
func (*Publication) Descriptor() ([]byte, []int) { return fileDescriptorTransit, []int{2} }

func (m *Publication) GetEntry() *Entry {
	if m != nil {
		return m.Entry
	}
	return nil
}

func (m *Publication) GetConcern() Concern {
	if m != nil {
		return m.Concern
	}
	return Concern_None
}

func (m *Publication) GetTimeout() uint64 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

// Entry represents a published entry in the message bus.
type Entry struct {
	// ID is the global ID that is assigned to the entry.
	// This will be assigned by the server and any value you specify will be ignored.
	ID uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// Topic is a dot-separated hierarchical list of keywords that may be matched by subscription prefixes.
	// For example "account.balance.deposit" may be subscribed via "account" if someone wants to see all
	// account actions, or "account.balance" if they are only interested in balance affecting actions.
	Topic string `protobuf:"bytes,5,opt,name=topic,proto3" json:"topic,omitempty"`
	// Lot defines a batch of items that belong together and can be subscribed to by using `Subscription.Allotments`.
	// For example if the Lot is a branch ID, you could have a process that subscribes to messages for several branches.
	Lot string `protobuf:"bytes,6,opt,name=lot,proto3" json:"lot,omitempty"`
	// Identity is a string that identifies this message as unique to the specific topic.
	// A delivery strategy may be defined for a queue that indicates how to deal with duplicate items.
	Identity string `protobuf:"bytes,7,opt,name=identity,proto3" json:"identity,omitempty"`
	// Message contains the item that you want to send to subscribers detailing the entry.
	Message *google_protobuf.Any `protobuf:"bytes,10,opt,name=message" json:"message,omitempty" depict:"-"`
	// NotBefore indicates that the message will only be deliverable on or after the given milliseconds since epoch.
	NotBefore uint64 `protobuf:"varint,20,opt,name=not_before,json=notBefore,proto3" json:"not_before,omitempty"`
	// NotAfter indicates that the message will be removed from all queues after the given milliseconds since epoch.
	NotAfter uint64 `protobuf:"varint,21,opt,name=not_after,json=notAfter,proto3" json:"not_after,omitempty"`
	// Meta contains additional custom metadata (other than message) that will be delivered with the message.
	// Note: Meta is delivered even if `Subscription.NoData` is specified by a subscriber.
	Meta map[string]string `protobuf:"bytes,90,rep,name=meta" json:"meta,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Entry) Reset()                    { *m = Entry{} }
func (m *Entry) String() string            { return proto.CompactTextString(m) }
func (*Entry) ProtoMessage()               {}
func (*Entry) Descriptor() ([]byte, []int) { return fileDescriptorTransit, []int{3} }

func (m *Entry) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Entry) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *Entry) GetLot() string {
	if m != nil {
		return m.Lot
	}
	return ""
}

func (m *Entry) GetIdentity() string {
	if m != nil {
		return m.Identity
	}
	return ""
}

func (m *Entry) GetMessage() *google_protobuf.Any {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *Entry) GetNotBefore() uint64 {
	if m != nil {
		return m.NotBefore
	}
	return 0
}

func (m *Entry) GetNotAfter() uint64 {
	if m != nil {
		return m.NotAfter
	}
	return 0
}

func (m *Entry) GetMeta() map[string]string {
	if m != nil {
		return m.Meta
	}
	return nil
}

// Subscription indicates what a process wishes to subscribe to and how it wants the queue configured.
type Subscription struct {
	// Prefix is the topic prefix you wish to subscribe to.
	// Prefix must match a complete segment prefix to allow you to receive the messages.
	Prefix string `protobuf:"bytes,1,opt,name=prefix,proto3" json:"prefix,omitempty"`
	// Group is your group name all subscribers with the same group name will share the processing of the messages.
	Group string `protobuf:"bytes,2,opt,name=group,proto3" json:"group,omitempty"`
	// Allotments contains a list of strings to match against `Entry.Lot`.
	// If the entry matches one of your Allotments, you will receive the message.
	// Entries are shared amongst all subscribers that specify the matching Lot.
	Allotments []string `protobuf:"bytes,10,rep,name=allotments" json:"allotments,omitempty"`
	// Delay specifies a minimum number of milliseconds before an entry becomes deliverable to you.
	Delay uint64 `protobuf:"varint,20,opt,name=delay,proto3" json:"delay,omitempty"`
	// MaxAge specifies a maximum number of milliseconds after which you're not interested in a message any more.
	MaxAge uint64 `protobuf:"varint,21,opt,name=max_age,json=maxAge,proto3" json:"max_age,omitempty"`
	// NoData indicates that you're not interested in the content of the message, and not to send it.
	// Specify this option to save bandwidth if you only care about knowing a topic happend not what it's about.
	NoData bool `protobuf:"varint,40,opt,name=no_data,json=noData,proto3" json:"no_data,omitempty"`
	// Distribution specifies what additional messages you want to receive other than your Allotted messages.
	Distribution DistributionStrategy `protobuf:"varint,80,opt,name=distribution,proto3,enum=DistributionStrategy" json:"distribution,omitempty"`
	// Delivery specifies how you want duplicate entries in the queue to be dealt with (queue-wide option).
	Delivery DeliveryStrategy `protobuf:"varint,81,opt,name=delivery,proto3,enum=DeliveryStrategy" json:"delivery,omitempty"`
}

func (m *Subscription) Reset()                    { *m = Subscription{} }
func (m *Subscription) String() string            { return proto.CompactTextString(m) }
func (*Subscription) ProtoMessage()               {}
func (*Subscription) Descriptor() ([]byte, []int) { return fileDescriptorTransit, []int{4} }

func (m *Subscription) GetPrefix() string {
	if m != nil {
		return m.Prefix
	}
	return ""
}

func (m *Subscription) GetGroup() string {
	if m != nil {
		return m.Group
	}
	return ""
}

func (m *Subscription) GetAllotments() []string {
	if m != nil {
		return m.Allotments
	}
	return nil
}

func (m *Subscription) GetDelay() uint64 {
	if m != nil {
		return m.Delay
	}
	return 0
}

func (m *Subscription) GetMaxAge() uint64 {
	if m != nil {
		return m.MaxAge
	}
	return 0
}

func (m *Subscription) GetNoData() bool {
	if m != nil {
		return m.NoData
	}
	return false
}

func (m *Subscription) GetDistribution() DistributionStrategy {
	if m != nil {
		return m.Distribution
	}
	return DistributionStrategy_Default
}

func (m *Subscription) GetDelivery() DeliveryStrategy {
	if m != nil {
		return m.Delivery
	}
	return DeliveryStrategy_Unspecified
}

// Notification is given to subscribers when a new message is available for them.
type Notification struct {
	// Contains the subscription detail to pass to Ack when you're finished processing the notification.
	Sub *Sub `protobuf:"bytes,1,opt,name=sub" json:"sub,omitempty"`
	// Entry is the item you're being notified about.
	Entry *Entry `protobuf:"bytes,2,opt,name=entry" json:"entry,omitempty"`
}

func (m *Notification) Reset()                    { *m = Notification{} }
func (m *Notification) String() string            { return proto.CompactTextString(m) }
func (*Notification) ProtoMessage()               {}
func (*Notification) Descriptor() ([]byte, []int) { return fileDescriptorTransit, []int{5} }

func (m *Notification) GetSub() *Sub {
	if m != nil {
		return m.Sub
	}
	return nil
}

func (m *Notification) GetEntry() *Entry {
	if m != nil {
		return m.Entry
	}
	return nil
}

// Acknowlegement is sent to the sever via the `Ack` command to indicate that you are finished with the given entry
// and wish to receive another.
type Acknowledgement struct {
	// Sub is the subscription you are acknowedging, you get this from the Notification.
	Sub *Sub `protobuf:"bytes,1,opt,name=sub" json:"sub,omitempty"`
	// Ack indicates whether this message should be acked or not.
	Ack bool `protobuf:"varint,2,opt,name=ack,proto3" json:"ack,omitempty"`
	// Close causes the subscription to be terminated without receiving a new message.
	Close bool `protobuf:"varint,3,opt,name=close,proto3" json:"close,omitempty"`
}

func (m *Acknowledgement) Reset()                    { *m = Acknowledgement{} }
func (m *Acknowledgement) String() string            { return proto.CompactTextString(m) }
func (*Acknowledgement) ProtoMessage()               {}
func (*Acknowledgement) Descriptor() ([]byte, []int) { return fileDescriptorTransit, []int{6} }

func (m *Acknowledgement) GetSub() *Sub {
	if m != nil {
		return m.Sub
	}
	return nil
}

func (m *Acknowledgement) GetAck() bool {
	if m != nil {
		return m.Ack
	}
	return false
}

func (m *Acknowledgement) GetClose() bool {
	if m != nil {
		return m.Close
	}
	return false
}

// Sub is provided to a subscriber in the notification and defines which entry in which inbox should be marked as
// delivered when the Sub is Acked.
type Sub struct {
	// Prefix is the topic prefix that the subscriber subscribed to.
	Prefix string `protobuf:"bytes,1,opt,name=prefix,proto3" json:"prefix,omitempty"`
	// Group is the group that the message was delivered to.
	Group string `protobuf:"bytes,2,opt,name=group,proto3" json:"group,omitempty"`
	// ID is the ID from the delivered entry.
	ID uint64 `protobuf:"varint,3,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *Sub) Reset()                    { *m = Sub{} }
func (m *Sub) String() string            { return proto.CompactTextString(m) }
func (*Sub) ProtoMessage()               {}
func (*Sub) Descriptor() ([]byte, []int) { return fileDescriptorTransit, []int{7} }

func (m *Sub) GetPrefix() string {
	if m != nil {
		return m.Prefix
	}
	return ""
}

func (m *Sub) GetGroup() string {
	if m != nil {
		return m.Group
	}
	return ""
}

func (m *Sub) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

// Acked is the result of an Acking of a Sub.
type Acked struct {
	// Success is set to true if the entry was acked successfully and false if not found or already acked.
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
}

func (m *Acked) Reset()                    { *m = Acked{} }
func (m *Acked) String() string            { return proto.CompactTextString(m) }
func (*Acked) ProtoMessage()               {}
func (*Acked) Descriptor() ([]byte, []int) { return fileDescriptorTransit, []int{8} }

func (m *Acked) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

type ApplyCommands struct {
	Commands []*Command `protobuf:"bytes,1,rep,name=commands" json:"commands,omitempty"`
}

func (m *ApplyCommands) Reset()                    { *m = ApplyCommands{} }
func (m *ApplyCommands) String() string            { return proto.CompactTextString(m) }
func (*ApplyCommands) ProtoMessage()               {}
func (*ApplyCommands) Descriptor() ([]byte, []int) { return fileDescriptorTransit, []int{9} }

func (m *ApplyCommands) GetCommands() []*Command {
	if m != nil {
		return m.Commands
	}
	return nil
}

type Command struct {
	Operation string `protobuf:"bytes,1,opt,name=operation,proto3" json:"operation,omitempty"`
	Key       string `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	Value     string `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	Compare   string `protobuf:"bytes,4,opt,name=compare,proto3" json:"compare,omitempty"`
	Versus    string `protobuf:"bytes,5,opt,name=versus,proto3" json:"versus,omitempty"`
}

func (m *Command) Reset()                    { *m = Command{} }
func (m *Command) String() string            { return proto.CompactTextString(m) }
func (*Command) ProtoMessage()               {}
func (*Command) Descriptor() ([]byte, []int) { return fileDescriptorTransit, []int{10} }

func (m *Command) GetOperation() string {
	if m != nil {
		return m.Operation
	}
	return ""
}

func (m *Command) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *Command) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *Command) GetCompare() string {
	if m != nil {
		return m.Compare
	}
	return ""
}

func (m *Command) GetVersus() string {
	if m != nil {
		return m.Versus
	}
	return ""
}

type Server struct {
	ID      string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Address string `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *Server) Reset()                    { *m = Server{} }
func (m *Server) String() string            { return proto.CompactTextString(m) }
func (*Server) ProtoMessage()               {}
func (*Server) Descriptor() ([]byte, []int) { return fileDescriptorTransit, []int{11} }

func (m *Server) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *Server) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type BoxItem struct {
	Entry    *Entry  `protobuf:"bytes,1,opt,name=entry" json:"entry,omitempty"`
	Inserted uint64  `protobuf:"varint,2,opt,name=inserted,proto3" json:"inserted,omitempty"`
	Concern  Concern `protobuf:"varint,3,opt,name=concern,proto3,enum=Concern" json:"concern,omitempty"`
	Notified bool    `protobuf:"varint,4,opt,name=notified,proto3" json:"notified,omitempty"`
	Expired  bool    `protobuf:"varint,5,opt,name=expired,proto3" json:"expired,omitempty"`
}

func (m *BoxItem) Reset()                    { *m = BoxItem{} }
func (m *BoxItem) String() string            { return proto.CompactTextString(m) }
func (*BoxItem) ProtoMessage()               {}
func (*BoxItem) Descriptor() ([]byte, []int) { return fileDescriptorTransit, []int{12} }

func (m *BoxItem) GetEntry() *Entry {
	if m != nil {
		return m.Entry
	}
	return nil
}

func (m *BoxItem) GetInserted() uint64 {
	if m != nil {
		return m.Inserted
	}
	return 0
}

func (m *BoxItem) GetConcern() Concern {
	if m != nil {
		return m.Concern
	}
	return Concern_None
}

func (m *BoxItem) GetNotified() bool {
	if m != nil {
		return m.Notified
	}
	return false
}

func (m *BoxItem) GetExpired() bool {
	if m != nil {
		return m.Expired
	}
	return false
}

type Snapshot struct {
	Boxes []*Box              `protobuf:"bytes,1,rep,name=boxes" json:"boxes,omitempty"`
	Items map[uint64]*BoxItem `protobuf:"bytes,2,rep,name=items" json:"items,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Snapshot) Reset()                    { *m = Snapshot{} }
func (m *Snapshot) String() string            { return proto.CompactTextString(m) }
func (*Snapshot) ProtoMessage()               {}
func (*Snapshot) Descriptor() ([]byte, []int) { return fileDescriptorTransit, []int{13} }

func (m *Snapshot) GetBoxes() []*Box {
	if m != nil {
		return m.Boxes
	}
	return nil
}

func (m *Snapshot) GetItems() map[uint64]*BoxItem {
	if m != nil {
		return m.Items
	}
	return nil
}

type Box struct {
	Prefix       string               `protobuf:"bytes,1,opt,name=prefix,proto3" json:"prefix,omitempty"`
	Group        string               `protobuf:"bytes,2,opt,name=group,proto3" json:"group,omitempty"`
	States       map[uint64]uint32    `protobuf:"bytes,10,rep,name=states" json:"states,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Distribution DistributionStrategy `protobuf:"varint,80,opt,name=distribution,proto3,enum=DistributionStrategy" json:"distribution,omitempty"`
	Delivery     DeliveryStrategy     `protobuf:"varint,81,opt,name=delivery,proto3,enum=DeliveryStrategy" json:"delivery,omitempty"`
}

func (m *Box) Reset()                    { *m = Box{} }
func (m *Box) String() string            { return proto.CompactTextString(m) }
func (*Box) ProtoMessage()               {}
func (*Box) Descriptor() ([]byte, []int) { return fileDescriptorTransit, []int{14} }

func (m *Box) GetPrefix() string {
	if m != nil {
		return m.Prefix
	}
	return ""
}

func (m *Box) GetGroup() string {
	if m != nil {
		return m.Group
	}
	return ""
}

func (m *Box) GetStates() map[uint64]uint32 {
	if m != nil {
		return m.States
	}
	return nil
}

func (m *Box) GetDistribution() DistributionStrategy {
	if m != nil {
		return m.Distribution
	}
	return DistributionStrategy_Default
}

func (m *Box) GetDelivery() DeliveryStrategy {
	if m != nil {
		return m.Delivery
	}
	return DeliveryStrategy_Unspecified
}

type Update struct {
	Entry *Entry        `protobuf:"bytes,1,opt,name=entry" json:"entry,omitempty"`
	Inbox *Subscription `protobuf:"bytes,2,opt,name=inbox" json:"inbox,omitempty"`
}

func (m *Update) Reset()                    { *m = Update{} }
func (m *Update) String() string            { return proto.CompactTextString(m) }
func (*Update) ProtoMessage()               {}
func (*Update) Descriptor() ([]byte, []int) { return fileDescriptorTransit, []int{15} }

func (m *Update) GetEntry() *Entry {
	if m != nil {
		return m.Entry
	}
	return nil
}

func (m *Update) GetInbox() *Subscription {
	if m != nil {
		return m.Inbox
	}
	return nil
}

type Success struct {
	Succeed bool   `protobuf:"varint,1,opt,name=succeed,proto3" json:"succeed,omitempty"`
	Error   string `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *Success) Reset()                    { *m = Success{} }
func (m *Success) String() string            { return proto.CompactTextString(m) }
func (*Success) ProtoMessage()               {}
func (*Success) Descriptor() ([]byte, []int) { return fileDescriptorTransit, []int{16} }

func (m *Success) GetSucceed() bool {
	if m != nil {
		return m.Succeed
	}
	return false
}

func (m *Success) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type String struct {
	Value string `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *String) Reset()                    { *m = String{} }
func (m *String) String() string            { return proto.CompactTextString(m) }
func (*String) ProtoMessage()               {}
func (*String) Descriptor() ([]byte, []int) { return fileDescriptorTransit, []int{17} }

func (m *String) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type Strings struct {
	Values []string `protobuf:"bytes,1,rep,name=values" json:"values,omitempty"`
}

func (m *Strings) Reset()                    { *m = Strings{} }
func (m *Strings) String() string            { return proto.CompactTextString(m) }
func (*Strings) ProtoMessage()               {}
func (*Strings) Descriptor() ([]byte, []int) { return fileDescriptorTransit, []int{18} }

func (m *Strings) GetValues() []string {
	if m != nil {
		return m.Values
	}
	return nil
}

type StringMap struct {
	Values map[string]string `protobuf:"bytes,1,rep,name=values" json:"values,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *StringMap) Reset()                    { *m = StringMap{} }
func (m *StringMap) String() string            { return proto.CompactTextString(m) }
func (*StringMap) ProtoMessage()               {}
func (*StringMap) Descriptor() ([]byte, []int) { return fileDescriptorTransit, []int{19} }

func (m *StringMap) GetValues() map[string]string {
	if m != nil {
		return m.Values
	}
	return nil
}

type Void struct {
}

func (m *Void) Reset()                    { *m = Void{} }
func (m *Void) String() string            { return proto.CompactTextString(m) }
func (*Void) ProtoMessage()               {}
func (*Void) Descriptor() ([]byte, []int) { return fileDescriptorTransit, []int{20} }

func init() {
	proto.RegisterType((*Pong)(nil), "Pong")
	golang_proto.RegisterType((*Pong)(nil), "Pong")
	proto.RegisterType((*Published)(nil), "Published")
	golang_proto.RegisterType((*Published)(nil), "Published")
	proto.RegisterType((*Publication)(nil), "Publication")
	golang_proto.RegisterType((*Publication)(nil), "Publication")
	proto.RegisterType((*Entry)(nil), "Entry")
	golang_proto.RegisterType((*Entry)(nil), "Entry")
	proto.RegisterType((*Subscription)(nil), "Subscription")
	golang_proto.RegisterType((*Subscription)(nil), "Subscription")
	proto.RegisterType((*Notification)(nil), "Notification")
	golang_proto.RegisterType((*Notification)(nil), "Notification")
	proto.RegisterType((*Acknowledgement)(nil), "Acknowledgement")
	golang_proto.RegisterType((*Acknowledgement)(nil), "Acknowledgement")
	proto.RegisterType((*Sub)(nil), "Sub")
	golang_proto.RegisterType((*Sub)(nil), "Sub")
	proto.RegisterType((*Acked)(nil), "Acked")
	golang_proto.RegisterType((*Acked)(nil), "Acked")
	proto.RegisterType((*ApplyCommands)(nil), "ApplyCommands")
	golang_proto.RegisterType((*ApplyCommands)(nil), "ApplyCommands")
	proto.RegisterType((*Command)(nil), "Command")
	golang_proto.RegisterType((*Command)(nil), "Command")
	proto.RegisterType((*Server)(nil), "Server")
	golang_proto.RegisterType((*Server)(nil), "Server")
	proto.RegisterType((*BoxItem)(nil), "BoxItem")
	golang_proto.RegisterType((*BoxItem)(nil), "BoxItem")
	proto.RegisterType((*Snapshot)(nil), "Snapshot")
	golang_proto.RegisterType((*Snapshot)(nil), "Snapshot")
	proto.RegisterType((*Box)(nil), "Box")
	golang_proto.RegisterType((*Box)(nil), "Box")
	proto.RegisterType((*Update)(nil), "Update")
	golang_proto.RegisterType((*Update)(nil), "Update")
	proto.RegisterType((*Success)(nil), "Success")
	golang_proto.RegisterType((*Success)(nil), "Success")
	proto.RegisterType((*String)(nil), "String")
	golang_proto.RegisterType((*String)(nil), "String")
	proto.RegisterType((*Strings)(nil), "Strings")
	golang_proto.RegisterType((*Strings)(nil), "Strings")
	proto.RegisterType((*StringMap)(nil), "StringMap")
	golang_proto.RegisterType((*StringMap)(nil), "StringMap")
	proto.RegisterType((*Void)(nil), "Void")
	golang_proto.RegisterType((*Void)(nil), "Void")
	proto.RegisterEnum("DistributionStrategy", DistributionStrategy_name, DistributionStrategy_value)
	golang_proto.RegisterEnum("DistributionStrategy", DistributionStrategy_name, DistributionStrategy_value)
	proto.RegisterEnum("DeliveryStrategy", DeliveryStrategy_name, DeliveryStrategy_value)
	golang_proto.RegisterEnum("DeliveryStrategy", DeliveryStrategy_name, DeliveryStrategy_value)
	proto.RegisterEnum("Concern", Concern_name, Concern_value)
	golang_proto.RegisterEnum("Concern", Concern_name, Concern_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Transit service

type TransitClient interface {
	// Ping tests server is alive.
	Ping(ctx context.Context, in *Pong, opts ...grpc.CallOption) (*Pong, error)
	// Publish takes a message entry and returns the published message id.
	Publish(ctx context.Context, in *Publication, opts ...grpc.CallOption) (*Published, error)
	// Subscribe takes topic and group details and returns a subscription stream.
	Subscribe(ctx context.Context, in *Subscription, opts ...grpc.CallOption) (Transit_SubscribeClient, error)
	// Ack acknowledges the successful receipt and processing of a message id.
	// Acknowledging a message causes you to receive a new message.
	Ack(ctx context.Context, in *Acknowledgement, opts ...grpc.CallOption) (*Acked, error)
	// ClusterApply is for applying a set of transformation commands to the cluster's state.
	ClusterApply(ctx context.Context, in *ApplyCommands, opts ...grpc.CallOption) (*Success, error)
	// ClusterGetKeys returns the state values for a given set of cluster keys.
	ClusterGetKeys(ctx context.Context, in *Strings, opts ...grpc.CallOption) (*StringMap, error)
	// ClusterList returns a list of keys and values, with the provided prefix from the cluster.
	ClusterList(ctx context.Context, in *String, opts ...grpc.CallOption) (*StringMap, error)
	// ClusterJoin makes the current leader server perform a join with the given server.
	ClusterJoin(ctx context.Context, in *Server, opts ...grpc.CallOption) (*Success, error)
	// ClusterLeader returns the gRPC address of the current cluster leader.
	ClusterLeader(ctx context.Context, in *Void, opts ...grpc.CallOption) (*String, error)
	// Dump is for fetching an entire snapshot of entries and queues from the leader server.
	Dump(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Snapshot, error)
	// Updates is for keeping track of updates from the leader server.
	Updates(ctx context.Context, opts ...grpc.CallOption) (Transit_UpdatesClient, error)
}

type transitClient struct {
	cc *grpc.ClientConn
}

func NewTransitClient(cc *grpc.ClientConn) TransitClient {
	return &transitClient{cc}
}

func (c *transitClient) Ping(ctx context.Context, in *Pong, opts ...grpc.CallOption) (*Pong, error) {
	out := new(Pong)
	err := grpc.Invoke(ctx, "/Transit/Ping", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transitClient) Publish(ctx context.Context, in *Publication, opts ...grpc.CallOption) (*Published, error) {
	out := new(Published)
	err := grpc.Invoke(ctx, "/Transit/Publish", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transitClient) Subscribe(ctx context.Context, in *Subscription, opts ...grpc.CallOption) (Transit_SubscribeClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Transit_serviceDesc.Streams[0], c.cc, "/Transit/Subscribe", opts...)
	if err != nil {
		return nil, err
	}
	x := &transitSubscribeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Transit_SubscribeClient interface {
	Recv() (*Notification, error)
	grpc.ClientStream
}

type transitSubscribeClient struct {
	grpc.ClientStream
}

func (x *transitSubscribeClient) Recv() (*Notification, error) {
	m := new(Notification)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *transitClient) Ack(ctx context.Context, in *Acknowledgement, opts ...grpc.CallOption) (*Acked, error) {
	out := new(Acked)
	err := grpc.Invoke(ctx, "/Transit/Ack", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transitClient) ClusterApply(ctx context.Context, in *ApplyCommands, opts ...grpc.CallOption) (*Success, error) {
	out := new(Success)
	err := grpc.Invoke(ctx, "/Transit/ClusterApply", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transitClient) ClusterGetKeys(ctx context.Context, in *Strings, opts ...grpc.CallOption) (*StringMap, error) {
	out := new(StringMap)
	err := grpc.Invoke(ctx, "/Transit/ClusterGetKeys", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transitClient) ClusterList(ctx context.Context, in *String, opts ...grpc.CallOption) (*StringMap, error) {
	out := new(StringMap)
	err := grpc.Invoke(ctx, "/Transit/ClusterList", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transitClient) ClusterJoin(ctx context.Context, in *Server, opts ...grpc.CallOption) (*Success, error) {
	out := new(Success)
	err := grpc.Invoke(ctx, "/Transit/ClusterJoin", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transitClient) ClusterLeader(ctx context.Context, in *Void, opts ...grpc.CallOption) (*String, error) {
	out := new(String)
	err := grpc.Invoke(ctx, "/Transit/ClusterLeader", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transitClient) Dump(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Snapshot, error) {
	out := new(Snapshot)
	err := grpc.Invoke(ctx, "/Transit/Dump", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transitClient) Updates(ctx context.Context, opts ...grpc.CallOption) (Transit_UpdatesClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Transit_serviceDesc.Streams[1], c.cc, "/Transit/Updates", opts...)
	if err != nil {
		return nil, err
	}
	x := &transitUpdatesClient{stream}
	return x, nil
}

type Transit_UpdatesClient interface {
	Send(*Success) error
	Recv() (*Update, error)
	grpc.ClientStream
}

type transitUpdatesClient struct {
	grpc.ClientStream
}

func (x *transitUpdatesClient) Send(m *Success) error {
	return x.ClientStream.SendMsg(m)
}

func (x *transitUpdatesClient) Recv() (*Update, error) {
	m := new(Update)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Transit service

type TransitServer interface {
	// Ping tests server is alive.
	Ping(context.Context, *Pong) (*Pong, error)
	// Publish takes a message entry and returns the published message id.
	Publish(context.Context, *Publication) (*Published, error)
	// Subscribe takes topic and group details and returns a subscription stream.
	Subscribe(*Subscription, Transit_SubscribeServer) error
	// Ack acknowledges the successful receipt and processing of a message id.
	// Acknowledging a message causes you to receive a new message.
	Ack(context.Context, *Acknowledgement) (*Acked, error)
	// ClusterApply is for applying a set of transformation commands to the cluster's state.
	ClusterApply(context.Context, *ApplyCommands) (*Success, error)
	// ClusterGetKeys returns the state values for a given set of cluster keys.
	ClusterGetKeys(context.Context, *Strings) (*StringMap, error)
	// ClusterList returns a list of keys and values, with the provided prefix from the cluster.
	ClusterList(context.Context, *String) (*StringMap, error)
	// ClusterJoin makes the current leader server perform a join with the given server.
	ClusterJoin(context.Context, *Server) (*Success, error)
	// ClusterLeader returns the gRPC address of the current cluster leader.
	ClusterLeader(context.Context, *Void) (*String, error)
	// Dump is for fetching an entire snapshot of entries and queues from the leader server.
	Dump(context.Context, *Void) (*Snapshot, error)
	// Updates is for keeping track of updates from the leader server.
	Updates(Transit_UpdatesServer) error
}

func RegisterTransitServer(s *grpc.Server, srv TransitServer) {
	s.RegisterService(&_Transit_serviceDesc, srv)
}

func _Transit_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Pong)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransitServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Transit/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransitServer).Ping(ctx, req.(*Pong))
	}
	return interceptor(ctx, in, info, handler)
}

func _Transit_Publish_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Publication)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransitServer).Publish(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Transit/Publish",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransitServer).Publish(ctx, req.(*Publication))
	}
	return interceptor(ctx, in, info, handler)
}

func _Transit_Subscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Subscription)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TransitServer).Subscribe(m, &transitSubscribeServer{stream})
}

type Transit_SubscribeServer interface {
	Send(*Notification) error
	grpc.ServerStream
}

type transitSubscribeServer struct {
	grpc.ServerStream
}

func (x *transitSubscribeServer) Send(m *Notification) error {
	return x.ServerStream.SendMsg(m)
}

func _Transit_Ack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Acknowledgement)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransitServer).Ack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Transit/Ack",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransitServer).Ack(ctx, req.(*Acknowledgement))
	}
	return interceptor(ctx, in, info, handler)
}

func _Transit_ClusterApply_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApplyCommands)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransitServer).ClusterApply(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Transit/ClusterApply",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransitServer).ClusterApply(ctx, req.(*ApplyCommands))
	}
	return interceptor(ctx, in, info, handler)
}

func _Transit_ClusterGetKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Strings)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransitServer).ClusterGetKeys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Transit/ClusterGetKeys",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransitServer).ClusterGetKeys(ctx, req.(*Strings))
	}
	return interceptor(ctx, in, info, handler)
}

func _Transit_ClusterList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(String)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransitServer).ClusterList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Transit/ClusterList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransitServer).ClusterList(ctx, req.(*String))
	}
	return interceptor(ctx, in, info, handler)
}

func _Transit_ClusterJoin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Server)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransitServer).ClusterJoin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Transit/ClusterJoin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransitServer).ClusterJoin(ctx, req.(*Server))
	}
	return interceptor(ctx, in, info, handler)
}

func _Transit_ClusterLeader_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransitServer).ClusterLeader(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Transit/ClusterLeader",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransitServer).ClusterLeader(ctx, req.(*Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _Transit_Dump_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransitServer).Dump(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Transit/Dump",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransitServer).Dump(ctx, req.(*Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _Transit_Updates_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(TransitServer).Updates(&transitUpdatesServer{stream})
}

type Transit_UpdatesServer interface {
	Send(*Update) error
	Recv() (*Success, error)
	grpc.ServerStream
}

type transitUpdatesServer struct {
	grpc.ServerStream
}

func (x *transitUpdatesServer) Send(m *Update) error {
	return x.ServerStream.SendMsg(m)
}

func (x *transitUpdatesServer) Recv() (*Success, error) {
	m := new(Success)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Transit_serviceDesc = grpc.ServiceDesc{
	ServiceName: "Transit",
	HandlerType: (*TransitServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Ping",
			Handler:    _Transit_Ping_Handler,
		},
		{
			MethodName: "Publish",
			Handler:    _Transit_Publish_Handler,
		},
		{
			MethodName: "Ack",
			Handler:    _Transit_Ack_Handler,
		},
		{
			MethodName: "ClusterApply",
			Handler:    _Transit_ClusterApply_Handler,
		},
		{
			MethodName: "ClusterGetKeys",
			Handler:    _Transit_ClusterGetKeys_Handler,
		},
		{
			MethodName: "ClusterList",
			Handler:    _Transit_ClusterList_Handler,
		},
		{
			MethodName: "ClusterJoin",
			Handler:    _Transit_ClusterJoin_Handler,
		},
		{
			MethodName: "ClusterLeader",
			Handler:    _Transit_ClusterLeader_Handler,
		},
		{
			MethodName: "Dump",
			Handler:    _Transit_Dump_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Subscribe",
			Handler:       _Transit_Subscribe_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Updates",
			Handler:       _Transit_Updates_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "transit.proto",
}

func init() { proto.RegisterFile("transit.proto", fileDescriptorTransit) }
func init() { golang_proto.RegisterFile("transit.proto", fileDescriptorTransit) }

var fileDescriptorTransit = []byte{
	// 1663 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x57, 0xdf, 0x8e, 0x1b, 0x49,
	0xd5, 0x9f, 0xf6, 0x7f, 0x1f, 0xcf, 0x4c, 0xbc, 0xf5, 0xcd, 0xe6, 0xeb, 0x98, 0x30, 0x71, 0x9a,
	0x5c, 0x18, 0x8b, 0x69, 0x67, 0x07, 0xed, 0xb2, 0x19, 0x24, 0xc0, 0xce, 0x20, 0x14, 0xb2, 0x1b,
	0x66, 0xdb, 0x6c, 0x40, 0x7b, 0x13, 0x95, 0xbb, 0xcf, 0x74, 0x4a, 0xd3, 0xee, 0x6a, 0xaa, 0xaa,
	0x1d, 0x5b, 0x51, 0x90, 0xd8, 0x07, 0xe0, 0x02, 0x24, 0xee, 0x78, 0x06, 0x5e, 0x81, 0x77, 0xe0,
	0x7e, 0x17, 0x05, 0x9e, 0x80, 0x27, 0x40, 0x55, 0xd5, 0xed, 0xe9, 0x89, 0x26, 0x2c, 0xb9, 0xe1,
	0xca, 0xf5, 0x3b, 0xe7, 0xd4, 0xa9, 0x73, 0x4e, 0xfd, 0xce, 0xe9, 0x32, 0xec, 0x29, 0x41, 0x53,
	0xc9, 0x94, 0x9f, 0x09, 0xae, 0xf8, 0xe0, 0x56, 0xcc, 0x79, 0x9c, 0xe0, 0xc4, 0xa0, 0x45, 0x7e,
	0x3e, 0xa1, 0xe9, 0xa6, 0x50, 0xdd, 0x2e, 0x54, 0x34, 0x63, 0x13, 0x9a, 0xa6, 0x5c, 0x51, 0xc5,
	0x78, 0x2a, 0x0b, 0xed, 0xf7, 0xcc, 0x4f, 0x78, 0x14, 0x63, 0x7a, 0x24, 0x5f, 0xd0, 0x38, 0x46,
	0x31, 0xe1, 0x99, 0xb1, 0xb8, 0xc6, 0xfa, 0x28, 0x66, 0xea, 0x79, 0xbe, 0xf0, 0x43, 0xbe, 0x9c,
	0xc4, 0x3c, 0xe6, 0x97, 0xe7, 0x69, 0x64, 0x80, 0x59, 0x15, 0xe6, 0x1f, 0x55, 0xcc, 0x97, 0x2f,
	0x98, 0xba, 0xe0, 0x2f, 0x26, 0x31, 0x3f, 0x32, 0xca, 0xa3, 0x15, 0x4d, 0x58, 0x44, 0x15, 0x17,
	0x72, 0xb2, 0x5d, 0xda, 0x7d, 0xde, 0x19, 0x34, 0xce, 0x78, 0x1a, 0x93, 0x9b, 0x50, 0x63, 0x91,
	0xeb, 0x0c, 0x9d, 0x51, 0x63, 0xd6, 0x7a, 0xfd, 0xd5, 0x9d, 0xda, 0xa3, 0xd3, 0xa0, 0xc6, 0x22,
	0x72, 0x13, 0x5a, 0x09, 0xd2, 0x08, 0x85, 0x5b, 0x1b, 0x3a, 0xa3, 0x6e, 0x50, 0x20, 0xe2, 0x42,
	0x5b, 0xaf, 0x58, 0x1a, 0xbb, 0xf5, 0xa1, 0x33, 0xea, 0x04, 0x25, 0xf4, 0x18, 0x74, 0xcf, 0xf2,
	0x45, 0xc2, 0xe4, 0x73, 0x8c, 0xc8, 0xc7, 0x15, 0xb7, 0x23, 0xeb, 0xf6, 0xf5, 0xd7, 0x77, 0x0e,
	0xfb, 0x3b, 0xe3, 0xc1, 0xa3, 0xd3, 0xe1, 0x32, 0x97, 0x6a, 0x48, 0x87, 0x19, 0x97, 0x4c, 0xb1,
	0x15, 0x0e, 0x59, 0xaa, 0x30, 0x46, 0x61, 0x0e, 0xf6, 0xa0, 0x1d, 0xf2, 0x34, 0x44, 0x91, 0xba,
	0x30, 0x74, 0x46, 0xfb, 0xc7, 0x1d, 0xff, 0xa1, 0xc5, 0x41, 0xa9, 0xf0, 0x18, 0xf4, 0xcc, 0x51,
	0xa1, 0xa9, 0x1c, 0xb9, 0x0d, 0x4d, 0x4c, 0x95, 0xd8, 0x98, 0xf3, 0x7a, 0xc7, 0x2d, 0xff, 0xa7,
	0x1a, 0x05, 0x56, 0xf8, 0xdf, 0x38, 0xd4, 0x59, 0x29, 0xb6, 0x44, 0x9e, 0x2b, 0xb7, 0xa7, 0x63,
	0x0e, 0x4a, 0xe8, 0xfd, 0xbd, 0x06, 0x4d, 0xe3, 0xee, 0xad, 0x95, 0xfa, 0x08, 0x9a, 0x8a, 0x67,
	0x2c, 0x74, 0x9b, 0xba, 0x50, 0xb3, 0xe1, 0xeb, 0xaf, 0xef, 0xdc, 0x1e, 0xbb, 0xd3, 0xa1, 0x11,
	0xda, 0x54, 0x17, 0x38, 0x94, 0x79, 0x96, 0x25, 0x0c, 0xa3, 0x5f, 0x3b, 0x81, 0x35, 0x27, 0x7d,
	0xa8, 0x27, 0x5c, 0xb9, 0x2d, 0x53, 0x5e, 0xbd, 0x24, 0x03, 0xe8, 0xb0, 0x08, 0x53, 0xc5, 0xd4,
	0xc6, 0x6d, 0x1b, 0xf1, 0x16, 0x93, 0x1f, 0x41, 0x7b, 0x89, 0x52, 0xd2, 0x18, 0x4d, 0x16, 0xbd,
	0xe3, 0x03, 0xdf, 0x92, 0xce, 0x2f, 0xf9, 0xe1, 0x4f, 0xd3, 0xcd, 0x6c, 0xff, 0x5f, 0x5f, 0xdd,
	0x81, 0x08, 0x33, 0x16, 0xaa, 0x13, 0xef, 0xc8, 0x0b, 0xca, 0x4d, 0xe4, 0xdb, 0x00, 0x29, 0x57,
	0xcf, 0x16, 0x78, 0xce, 0x05, 0xba, 0x07, 0x26, 0xc9, 0x6e, 0xca, 0xd5, 0xcc, 0x08, 0xc8, 0xb7,
	0x40, 0x83, 0x67, 0xf4, 0x5c, 0xa1, 0x70, 0xdf, 0x37, 0xda, 0x4e, 0xca, 0xd5, 0x54, 0x63, 0x72,
	0x0f, 0x1a, 0x4b, 0x54, 0xd4, 0xfd, 0x62, 0x58, 0x1f, 0xf5, 0x8e, 0xfb, 0xb6, 0xbc, 0xfe, 0xa7,
	0xa8, 0xa8, 0x2d, 0xb4, 0xd1, 0x0e, 0x7e, 0x00, 0xdd, 0xad, 0x48, 0x27, 0x77, 0x81, 0xf6, 0x42,
	0xba, 0x81, 0x5e, 0x92, 0x03, 0x68, 0xae, 0x68, 0x92, 0x63, 0xc1, 0x27, 0x0b, 0x4e, 0x6a, 0x1f,
	0x3b, 0xde, 0xef, 0x6b, 0xb0, 0x3b, 0xcf, 0x17, 0x32, 0x14, 0xcc, 0x74, 0x85, 0xe6, 0x5e, 0x26,
	0xf0, 0x9c, 0xad, 0x8b, 0xfd, 0x05, 0xd2, 0x2e, 0x62, 0xc1, 0xf3, 0xac, 0x74, 0x61, 0x00, 0x39,
	0x04, 0xa0, 0x49, 0xc2, 0xd5, 0x12, 0x53, 0x25, 0x5d, 0x18, 0xd6, 0x47, 0xdd, 0xa0, 0x22, 0xd1,
	0xbb, 0x22, 0x4c, 0xe8, 0xa6, 0x48, 0xda, 0x02, 0xf2, 0xff, 0xd0, 0x5e, 0xd2, 0xf5, 0x33, 0x5d,
	0x4f, 0x9b, 0x6e, 0x6b, 0x49, 0xd7, 0xd3, 0x18, 0xb5, 0x22, 0xe5, 0xcf, 0x22, 0xaa, 0xa8, 0x3b,
	0x32, 0x04, 0x6f, 0xa5, 0xfc, 0x94, 0x2a, 0x4a, 0x1e, 0xc0, 0x6e, 0xc4, 0xa4, 0x12, 0x6c, 0x91,
	0xeb, 0x28, 0xdd, 0x33, 0x43, 0xa6, 0xf7, 0xfd, 0xd3, 0x8a, 0x70, 0xae, 0x04, 0x55, 0x18, 0x6f,
	0x82, 0x2b, 0xa6, 0xe4, 0x08, 0x3a, 0x11, 0x26, 0x6c, 0x85, 0x62, 0xe3, 0x7e, 0x66, 0xb6, 0xbd,
	0xe7, 0x9f, 0x16, 0x82, 0xed, 0x96, 0xad, 0x89, 0x77, 0x0a, 0xbb, 0x4f, 0xb8, 0x62, 0xe7, 0x25,
	0xbf, 0x6f, 0x42, 0x5d, 0xe6, 0x8b, 0x82, 0xdd, 0x0d, 0x7f, 0x9e, 0x2f, 0x02, 0x2d, 0xb8, 0xe4,
	0x7d, 0xed, 0x1a, 0xde, 0x7b, 0x9f, 0xc1, 0x8d, 0x69, 0x78, 0x91, 0xf2, 0x17, 0x09, 0x46, 0x31,
	0xea, 0x5a, 0xbc, 0xd5, 0x51, 0x1f, 0xea, 0x34, 0xbc, 0x30, 0x6e, 0x3a, 0x81, 0x5e, 0xea, 0xa2,
	0x85, 0x09, 0x97, 0x58, 0x34, 0xb9, 0x05, 0xde, 0x63, 0xa8, 0xcf, 0xf3, 0xc5, 0x3b, 0xde, 0x8f,
	0xed, 0x9b, 0xfa, 0x9b, 0x7d, 0xe3, 0xdd, 0x85, 0xe6, 0x34, 0xbc, 0xc0, 0x48, 0x37, 0x9f, 0xcc,
	0xc3, 0x10, 0xa5, 0x34, 0xfe, 0x3a, 0x41, 0x09, 0xbd, 0x0f, 0x61, 0x6f, 0x9a, 0x65, 0xc9, 0xe6,
	0x21, 0x5f, 0x2e, 0x69, 0x1a, 0x49, 0x72, 0x0f, 0x3a, 0x61, 0xb1, 0x76, 0x1d, 0xc3, 0x46, 0xdd,
	0xcc, 0x46, 0x10, 0x6c, 0x35, 0xde, 0xef, 0x1c, 0x68, 0x17, 0x52, 0x72, 0x1b, 0xba, 0x3c, 0x43,
	0x61, 0x0a, 0x59, 0x84, 0x7b, 0x29, 0x28, 0x69, 0x5a, 0xbb, 0x86, 0xa6, 0xf5, 0x0a, 0x4d, 0x75,
	0x88, 0x21, 0x5f, 0x66, 0x54, 0xa0, 0xdb, 0x30, 0xf2, 0x12, 0xea, 0x5a, 0xac, 0x50, 0xc8, 0x5c,
	0xda, 0xf6, 0x0f, 0x0a, 0xe4, 0x9d, 0x40, 0x6b, 0x8e, 0x62, 0x85, 0xa2, 0x32, 0x37, 0xba, 0x57,
	0xe6, 0x86, 0x0b, 0x6d, 0x1a, 0x45, 0x42, 0xa7, 0x6d, 0xcf, 0x2f, 0xa1, 0xf7, 0x67, 0x07, 0xda,
	0x33, 0xbe, 0x7e, 0xa4, 0x70, 0xf9, 0x0d, 0xb3, 0x4d, 0x4f, 0x8c, 0x54, 0xa2, 0x50, 0x18, 0x19,
	0x27, 0x8d, 0x60, 0x8b, 0xab, 0x73, 0xaf, 0xfe, 0xb6, 0xb9, 0x37, 0x00, 0xdd, 0xe5, 0xec, 0x9c,
	0x61, 0x64, 0x12, 0xeb, 0x04, 0x5b, 0xac, 0xe3, 0xc3, 0x75, 0xc6, 0x04, 0x46, 0x26, 0xb5, 0x4e,
	0x50, 0x42, 0xef, 0x4f, 0x0e, 0x74, 0xe6, 0x29, 0xcd, 0xe4, 0x73, 0x33, 0xb4, 0x9a, 0x0b, 0xbe,
	0xc6, 0xf2, 0x3e, 0x1a, 0xfe, 0x8c, 0xaf, 0x03, 0x2b, 0x22, 0x63, 0x68, 0x32, 0x85, 0x4b, 0x9d,
	0x60, 0xdd, 0x8c, 0xac, 0x72, 0x97, 0xaf, 0x73, 0x93, 0x45, 0x2a, 0xc6, 0x64, 0x30, 0x03, 0xb8,
	0x14, 0x56, 0xe7, 0x47, 0xc3, 0x5e, 0xcc, 0x61, 0x75, 0x7e, 0xe8, 0x7b, 0x2f, 0x2a, 0x54, 0x9d,
	0x24, 0x5f, 0xd6, 0xa0, 0x3e, 0xe3, 0xeb, 0x77, 0x24, 0xe8, 0x08, 0x5a, 0x52, 0x51, 0x85, 0x76,
	0x78, 0xe8, 0x01, 0x37, 0xe3, 0x6b, 0x7f, 0x6e, 0x44, 0x36, 0xc4, 0x42, 0xff, 0xbf, 0x1b, 0x01,
	0x83, 0x07, 0xd0, 0xab, 0x04, 0x70, 0x4d, 0x39, 0xae, 0x8c, 0xd3, 0xbd, 0x6a, 0x11, 0x1e, 0x43,
	0xeb, 0xf3, 0x2c, 0xa2, 0x0a, 0xbf, 0x81, 0x3b, 0xdf, 0x81, 0x26, 0x4b, 0x17, 0x7c, 0x5d, 0x14,
	0x74, 0xcf, 0xaf, 0xce, 0xe0, 0xc0, 0xea, 0xbc, 0x07, 0xd0, 0x9e, 0xdb, 0x66, 0xdc, 0xb6, 0x29,
	0x46, 0x57, 0xda, 0x14, 0x23, 0x1d, 0x0b, 0x0a, 0xc1, 0xcb, 0xa7, 0x82, 0x05, 0xde, 0x21, 0xb4,
	0xe6, 0x4a, 0xb0, 0x34, 0xbe, 0x8c, 0xd5, 0xa9, 0xf4, 0x94, 0x77, 0x17, 0xda, 0x56, 0x2f, 0x4d,
	0x13, 0x69, 0x99, 0x25, 0x91, 0x6e, 0x22, 0x83, 0xbc, 0x15, 0x74, 0xad, 0xc9, 0xa7, 0x34, 0x23,
	0xfe, 0x15, 0xa3, 0xde, 0xf1, 0x4d, 0x7f, 0xab, 0xf3, 0x9f, 0x1a, 0x45, 0x71, 0x59, 0xd6, 0x4a,
	0x97, 0xb0, 0x22, 0x7e, 0xa7, 0x2f, 0x52, 0x0b, 0x1a, 0x4f, 0x39, 0x8b, 0xc6, 0xbf, 0x80, 0x83,
	0xeb, 0xae, 0x96, 0xf4, 0xa0, 0x7d, 0x8a, 0xe7, 0x34, 0x4f, 0x54, 0x7f, 0x87, 0xec, 0x41, 0x77,
	0x2a, 0x16, 0x4c, 0x09, 0x2a, 0x36, 0x7d, 0x47, 0xc3, 0x00, 0x7f, 0x93, 0xa3, 0x54, 0x18, 0xf5,
	0x6b, 0x64, 0x17, 0x3a, 0x53, 0x29, 0x59, 0x9c, 0x62, 0xd4, 0xaf, 0x8f, 0x17, 0xd0, 0x7f, 0xf3,
	0xd2, 0xc9, 0x0d, 0xe8, 0x7d, 0x9e, 0xca, 0x0c, 0x43, 0xd3, 0x76, 0xfd, 0x1d, 0xb2, 0x0f, 0xa0,
	0x1b, 0x35, 0x17, 0x02, 0x53, 0xd5, 0x77, 0x48, 0x07, 0x1a, 0xa7, 0x82, 0x67, 0xfd, 0x9a, 0x3e,
	0x37, 0xc0, 0x2c, 0xa1, 0x21, 0xf6, 0xeb, 0x04, 0xa0, 0xf5, 0x28, 0x4e, 0xb9, 0xc0, 0x7e, 0x43,
	0xaf, 0xe7, 0x28, 0x18, 0x4d, 0xfa, 0xcd, 0xf1, 0x13, 0x3d, 0xfc, 0x6c, 0x7b, 0x77, 0xa0, 0xf1,
	0x84, 0xa7, 0xd8, 0xdf, 0xd1, 0x61, 0x04, 0x18, 0x22, 0x5b, 0x61, 0x64, 0x63, 0x2c, 0xc2, 0x30,
	0x31, 0xee, 0x41, 0xf7, 0x21, 0x4f, 0xcf, 0x99, 0x58, 0xea, 0x20, 0x35, 0x3c, 0x13, 0x5c, 0xdf,
	0x39, 0x46, 0xfd, 0xc6, 0xf1, 0x5f, 0x1a, 0xd0, 0xfe, 0xa5, 0x7d, 0x09, 0x93, 0x09, 0x34, 0xce,
	0xf4, 0x8d, 0x36, 0x7d, 0xfd, 0x78, 0x1c, 0xd8, 0x1f, 0xef, 0xd6, 0x97, 0x7f, 0xfb, 0xe7, 0x1f,
	0x6b, 0xff, 0x47, 0xde, 0x33, 0x0f, 0xe0, 0xd5, 0x07, 0x93, 0x8c, 0xa5, 0xf1, 0xe4, 0x25, 0x8b,
	0x5e, 0x91, 0x1f, 0x43, 0xbb, 0x78, 0x14, 0x92, 0x5d, 0xbf, 0xf2, 0x66, 0x1b, 0x80, 0xbf, 0x7d,
	0x2c, 0x7a, 0x03, 0xb3, 0xff, 0xc0, 0xbb, 0xb1, 0xdd, 0x6f, 0x55, 0x27, 0xce, 0x98, 0xfc, 0x0a,
	0xba, 0x05, 0x2f, 0x17, 0x48, 0xae, 0x72, 0x74, 0xb0, 0xe7, 0x57, 0x3f, 0x93, 0xde, 0xd8, 0xb8,
	0xb9, 0x47, 0xbc, 0xd2, 0x8d, 0x2c, 0x37, 0x4e, 0x5e, 0xda, 0x01, 0xf0, 0x6a, 0xf2, 0xd2, 0xb4,
	0xfc, 0xab, 0xfb, 0x0e, 0x79, 0x0a, 0xf5, 0x69, 0x78, 0x41, 0xfa, 0xfe, 0x1b, 0x1f, 0xc9, 0x41,
	0xcb, 0x37, 0x9f, 0x25, 0xef, 0x43, 0xe3, 0x6e, 0x42, 0x8e, 0x4a, 0x77, 0x34, 0xbc, 0x98, 0xbc,
	0x94, 0xf9, 0xc2, 0xdf, 0x3a, 0xd3, 0xc0, 0x3a, 0xb4, 0x6b, 0x9d, 0xf1, 0x18, 0x76, 0x1f, 0x26,
	0xb9, 0x54, 0x28, 0xcc, 0xa7, 0x8b, 0xec, 0xfb, 0x57, 0x3e, 0x61, 0x83, 0x8e, 0x5f, 0x34, 0x94,
	0xb7, 0x43, 0x46, 0xb0, 0x5f, 0xd8, 0xfe, 0x0c, 0xd5, 0x63, 0xdc, 0x48, 0xd2, 0x29, 0x48, 0x2d,
	0x07, 0x70, 0x49, 0x6f, 0x6f, 0x87, 0xdc, 0x83, 0x5e, 0x61, 0xf9, 0x09, 0x93, 0x8a, 0xb4, 0x0b,
	0xe5, 0x1b, 0x56, 0xde, 0xd6, 0xea, 0xe7, 0x9c, 0xa5, 0xda, 0xca, 0x7c, 0x82, 0xae, 0x9c, 0x79,
	0x17, 0xf6, 0x4a, 0x4f, 0xf6, 0x45, 0xdf, 0xf4, 0x35, 0xd7, 0x07, 0xa5, 0x4b, 0x6f, 0x87, 0x0c,
	0xa0, 0x71, 0x9a, 0x2f, 0xb3, 0x52, 0xd3, 0xdd, 0x8e, 0x6d, 0x73, 0x44, 0xdb, 0x4e, 0x17, 0x13,
	0xab, 0xf5, 0x3a, 0x68, 0xfb, 0x56, 0xe6, 0xed, 0x8c, 0x9c, 0xfb, 0xce, 0xec, 0xb7, 0x7f, 0x98,
	0x7e, 0x42, 0x9a, 0xc7, 0xf5, 0x0f, 0xfc, 0xfb, 0x63, 0xa7, 0x26, 0x7e, 0x02, 0xb7, 0x0a, 0xfe,
	0x0c, 0xa5, 0x89, 0x67, 0x28, 0xd0, 0x3c, 0xfd, 0xb9, 0x9e, 0x42, 0xcf, 0x95, 0xca, 0xe4, 0xc9,
	0x64, 0x52, 0xf9, 0x1f, 0x93, 0x62, 0x24, 0x43, 0x1e, 0xe1, 0xa4, 0xf8, 0x03, 0xf6, 0xd7, 0x7f,
	0x1c, 0x3a, 0x5f, 0x7c, 0xf7, 0x3f, 0x18, 0xd8, 0xff, 0x48, 0x3f, 0x2c, 0xd0, 0xa2, 0x65, 0xe0,
	0xf7, 0xff, 0x1d, 0x00, 0x00, 0xff, 0xff, 0xdd, 0x62, 0xe0, 0x6f, 0xc1, 0x0d, 0x00, 0x00,
}
