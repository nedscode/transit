// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: transit.proto

/*
Package transit is a generated protocol buffer package.

It is generated from these files:
	transit.proto

It has these top-level messages:
	Pong
	Publication
	Entry
	Subscription
	Notification
	Sub
	Acked
	ApplyCommands
	Command
	Server
	Success
	String
	Strings
	StringMap
	Void
*/
package transit

import proto "github.com/gogo/protobuf/proto"
import golang_proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/golang/protobuf/ptypes/any"
import _ "github.com/gogo/googleapis/google/api"
import _ "github.com/grpc-ecosystem/grpc-gateway/protoc-gen-swagger/options"
import _ "github.com/gogo/protobuf/gogoproto"
import _ "github.com/mwitkow/go-proto-validators"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type DistributionStrategy int32

const (
	// Arbitrary distribution means that any processor may get any message.
	DistributionStrategy_Arbitrary DistributionStrategy = 0
	// Requested distribution limits messages to processors that have requested type of the specific lot.
	DistributionStrategy_Requested DistributionStrategy = 1
	// Assigned distribution will assign unrequested lots to processors based on load.
	DistributionStrategy_Assigned DistributionStrategy = 2
)

var DistributionStrategy_name = map[int32]string{
	0: "Arbitrary",
	1: "Requested",
	2: "Assigned",
}
var DistributionStrategy_value = map[string]int32{
	"Arbitrary": 0,
	"Requested": 1,
	"Assigned":  2,
}

func (x DistributionStrategy) String() string {
	return proto.EnumName(DistributionStrategy_name, int32(x))
}
func (DistributionStrategy) EnumDescriptor() ([]byte, []int) { return fileDescriptorTransit, []int{0} }

type DeliveryStrategy int32

const (
	// Concurrent messages are not treated specially.
	DeliveryStrategy_Concurrent DeliveryStrategy = 0
	// Drop means if there's currently one waiting, don't bother with this one and drop it.
	DeliveryStrategy_Drop DeliveryStrategy = 1
	// Replace means if there's currently one waiting, replace it with this one.
	DeliveryStrategy_Replace DeliveryStrategy = 2
	// Ignore means if there's currently one waiting, delete it and place this one at the back of the queue.
	DeliveryStrategy_Ignore DeliveryStrategy = 3
	// A Serial message will not begin processing a duplicate identity message at the same time as another.
	DeliveryStrategy_Serial DeliveryStrategy = 4
)

var DeliveryStrategy_name = map[int32]string{
	0: "Concurrent",
	1: "Drop",
	2: "Replace",
	3: "Ignore",
	4: "Serial",
}
var DeliveryStrategy_value = map[string]int32{
	"Concurrent": 0,
	"Drop":       1,
	"Replace":    2,
	"Ignore":     3,
	"Serial":     4,
}

func (x DeliveryStrategy) String() string {
	return proto.EnumName(DeliveryStrategy_name, int32(x))
}
func (DeliveryStrategy) EnumDescriptor() ([]byte, []int) { return fileDescriptorTransit, []int{1} }

type Pong struct {
	ID      uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Leader  string `protobuf:"bytes,2,opt,name=leader,proto3" json:"leader,omitempty"`
	Leading bool   `protobuf:"varint,3,opt,name=leading,proto3" json:"leading,omitempty"`
}

func (m *Pong) Reset()                    { *m = Pong{} }
func (m *Pong) String() string            { return proto.CompactTextString(m) }
func (*Pong) ProtoMessage()               {}
func (*Pong) Descriptor() ([]byte, []int) { return fileDescriptorTransit, []int{0} }

func (m *Pong) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Pong) GetLeader() string {
	if m != nil {
		return m.Leader
	}
	return ""
}

func (m *Pong) GetLeading() bool {
	if m != nil {
		return m.Leading
	}
	return false
}

type Publication struct {
	ID uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *Publication) Reset()                    { *m = Publication{} }
func (m *Publication) String() string            { return proto.CompactTextString(m) }
func (*Publication) ProtoMessage()               {}
func (*Publication) Descriptor() ([]byte, []int) { return fileDescriptorTransit, []int{1} }

func (m *Publication) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

type Entry struct {
	ID        uint64               `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Topic     string               `protobuf:"bytes,5,opt,name=topic,proto3" json:"topic,omitempty"`
	Lot       string               `protobuf:"bytes,6,opt,name=lot,proto3" json:"lot,omitempty"`
	Identity  string               `protobuf:"bytes,7,opt,name=identity,proto3" json:"identity,omitempty"`
	Message   *google_protobuf.Any `protobuf:"bytes,10,opt,name=message" json:"message,omitempty"`
	NotBefore uint64               `protobuf:"varint,20,opt,name=not_before,json=notBefore,proto3" json:"not_before,omitempty"`
	NotAfter  uint64               `protobuf:"varint,21,opt,name=not_after,json=notAfter,proto3" json:"not_after,omitempty"`
	Meta      map[string]string    `protobuf:"bytes,90,rep,name=meta" json:"meta,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Entry) Reset()                    { *m = Entry{} }
func (m *Entry) String() string            { return proto.CompactTextString(m) }
func (*Entry) ProtoMessage()               {}
func (*Entry) Descriptor() ([]byte, []int) { return fileDescriptorTransit, []int{2} }

func (m *Entry) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Entry) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *Entry) GetLot() string {
	if m != nil {
		return m.Lot
	}
	return ""
}

func (m *Entry) GetIdentity() string {
	if m != nil {
		return m.Identity
	}
	return ""
}

func (m *Entry) GetMessage() *google_protobuf.Any {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *Entry) GetNotBefore() uint64 {
	if m != nil {
		return m.NotBefore
	}
	return 0
}

func (m *Entry) GetNotAfter() uint64 {
	if m != nil {
		return m.NotAfter
	}
	return 0
}

func (m *Entry) GetMeta() map[string]string {
	if m != nil {
		return m.Meta
	}
	return nil
}

type Subscription struct {
	Prefix       string               `protobuf:"bytes,1,opt,name=prefix,proto3" json:"prefix,omitempty"`
	Group        string               `protobuf:"bytes,2,opt,name=group,proto3" json:"group,omitempty"`
	Allotments   []string             `protobuf:"bytes,10,rep,name=allotments" json:"allotments,omitempty"`
	Delay        uint64               `protobuf:"varint,20,opt,name=delay,proto3" json:"delay,omitempty"`
	MaxAge       uint64               `protobuf:"varint,21,opt,name=max_age,json=maxAge,proto3" json:"max_age,omitempty"`
	Distribution DistributionStrategy `protobuf:"varint,30,opt,name=distribution,proto3,enum=DistributionStrategy" json:"distribution,omitempty"`
	Delivery     DeliveryStrategy     `protobuf:"varint,31,opt,name=delivery,proto3,enum=DeliveryStrategy" json:"delivery,omitempty"`
}

func (m *Subscription) Reset()                    { *m = Subscription{} }
func (m *Subscription) String() string            { return proto.CompactTextString(m) }
func (*Subscription) ProtoMessage()               {}
func (*Subscription) Descriptor() ([]byte, []int) { return fileDescriptorTransit, []int{3} }

func (m *Subscription) GetPrefix() string {
	if m != nil {
		return m.Prefix
	}
	return ""
}

func (m *Subscription) GetGroup() string {
	if m != nil {
		return m.Group
	}
	return ""
}

func (m *Subscription) GetAllotments() []string {
	if m != nil {
		return m.Allotments
	}
	return nil
}

func (m *Subscription) GetDelay() uint64 {
	if m != nil {
		return m.Delay
	}
	return 0
}

func (m *Subscription) GetMaxAge() uint64 {
	if m != nil {
		return m.MaxAge
	}
	return 0
}

func (m *Subscription) GetDistribution() DistributionStrategy {
	if m != nil {
		return m.Distribution
	}
	return DistributionStrategy_Arbitrary
}

func (m *Subscription) GetDelivery() DeliveryStrategy {
	if m != nil {
		return m.Delivery
	}
	return DeliveryStrategy_Concurrent
}

type Notification struct {
	Sub   *Sub   `protobuf:"bytes,1,opt,name=sub" json:"sub,omitempty"`
	Entry *Entry `protobuf:"bytes,2,opt,name=entry" json:"entry,omitempty"`
}

func (m *Notification) Reset()                    { *m = Notification{} }
func (m *Notification) String() string            { return proto.CompactTextString(m) }
func (*Notification) ProtoMessage()               {}
func (*Notification) Descriptor() ([]byte, []int) { return fileDescriptorTransit, []int{4} }

func (m *Notification) GetSub() *Sub {
	if m != nil {
		return m.Sub
	}
	return nil
}

func (m *Notification) GetEntry() *Entry {
	if m != nil {
		return m.Entry
	}
	return nil
}

type Sub struct {
	Prefix string `protobuf:"bytes,1,opt,name=prefix,proto3" json:"prefix,omitempty"`
	Group  string `protobuf:"bytes,2,opt,name=group,proto3" json:"group,omitempty"`
	ID     uint64 `protobuf:"varint,3,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *Sub) Reset()                    { *m = Sub{} }
func (m *Sub) String() string            { return proto.CompactTextString(m) }
func (*Sub) ProtoMessage()               {}
func (*Sub) Descriptor() ([]byte, []int) { return fileDescriptorTransit, []int{5} }

func (m *Sub) GetPrefix() string {
	if m != nil {
		return m.Prefix
	}
	return ""
}

func (m *Sub) GetGroup() string {
	if m != nil {
		return m.Group
	}
	return ""
}

func (m *Sub) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

type Acked struct {
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
}

func (m *Acked) Reset()                    { *m = Acked{} }
func (m *Acked) String() string            { return proto.CompactTextString(m) }
func (*Acked) ProtoMessage()               {}
func (*Acked) Descriptor() ([]byte, []int) { return fileDescriptorTransit, []int{6} }

func (m *Acked) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

type ApplyCommands struct {
	Commands []*Command `protobuf:"bytes,1,rep,name=commands" json:"commands,omitempty"`
}

func (m *ApplyCommands) Reset()                    { *m = ApplyCommands{} }
func (m *ApplyCommands) String() string            { return proto.CompactTextString(m) }
func (*ApplyCommands) ProtoMessage()               {}
func (*ApplyCommands) Descriptor() ([]byte, []int) { return fileDescriptorTransit, []int{7} }

func (m *ApplyCommands) GetCommands() []*Command {
	if m != nil {
		return m.Commands
	}
	return nil
}

type Command struct {
	Operation string `protobuf:"bytes,1,opt,name=operation,proto3" json:"operation,omitempty"`
	Key       string `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	Value     string `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	Compare   string `protobuf:"bytes,4,opt,name=compare,proto3" json:"compare,omitempty"`
	Versus    string `protobuf:"bytes,5,opt,name=versus,proto3" json:"versus,omitempty"`
}

func (m *Command) Reset()                    { *m = Command{} }
func (m *Command) String() string            { return proto.CompactTextString(m) }
func (*Command) ProtoMessage()               {}
func (*Command) Descriptor() ([]byte, []int) { return fileDescriptorTransit, []int{8} }

func (m *Command) GetOperation() string {
	if m != nil {
		return m.Operation
	}
	return ""
}

func (m *Command) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *Command) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *Command) GetCompare() string {
	if m != nil {
		return m.Compare
	}
	return ""
}

func (m *Command) GetVersus() string {
	if m != nil {
		return m.Versus
	}
	return ""
}

type Server struct {
	ID      string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Address string `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *Server) Reset()                    { *m = Server{} }
func (m *Server) String() string            { return proto.CompactTextString(m) }
func (*Server) ProtoMessage()               {}
func (*Server) Descriptor() ([]byte, []int) { return fileDescriptorTransit, []int{9} }

func (m *Server) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *Server) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type Success struct {
	Succeed bool   `protobuf:"varint,1,opt,name=succeed,proto3" json:"succeed,omitempty"`
	Error   string `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *Success) Reset()                    { *m = Success{} }
func (m *Success) String() string            { return proto.CompactTextString(m) }
func (*Success) ProtoMessage()               {}
func (*Success) Descriptor() ([]byte, []int) { return fileDescriptorTransit, []int{10} }

func (m *Success) GetSucceed() bool {
	if m != nil {
		return m.Succeed
	}
	return false
}

func (m *Success) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type String struct {
	Value string `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *String) Reset()                    { *m = String{} }
func (m *String) String() string            { return proto.CompactTextString(m) }
func (*String) ProtoMessage()               {}
func (*String) Descriptor() ([]byte, []int) { return fileDescriptorTransit, []int{11} }

func (m *String) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type Strings struct {
	Values []string `protobuf:"bytes,1,rep,name=values" json:"values,omitempty"`
}

func (m *Strings) Reset()                    { *m = Strings{} }
func (m *Strings) String() string            { return proto.CompactTextString(m) }
func (*Strings) ProtoMessage()               {}
func (*Strings) Descriptor() ([]byte, []int) { return fileDescriptorTransit, []int{12} }

func (m *Strings) GetValues() []string {
	if m != nil {
		return m.Values
	}
	return nil
}

type StringMap struct {
	Values map[string]string `protobuf:"bytes,1,rep,name=values" json:"values,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *StringMap) Reset()                    { *m = StringMap{} }
func (m *StringMap) String() string            { return proto.CompactTextString(m) }
func (*StringMap) ProtoMessage()               {}
func (*StringMap) Descriptor() ([]byte, []int) { return fileDescriptorTransit, []int{13} }

func (m *StringMap) GetValues() map[string]string {
	if m != nil {
		return m.Values
	}
	return nil
}

type Void struct {
}

func (m *Void) Reset()                    { *m = Void{} }
func (m *Void) String() string            { return proto.CompactTextString(m) }
func (*Void) ProtoMessage()               {}
func (*Void) Descriptor() ([]byte, []int) { return fileDescriptorTransit, []int{14} }

func init() {
	proto.RegisterType((*Pong)(nil), "Pong")
	golang_proto.RegisterType((*Pong)(nil), "Pong")
	proto.RegisterType((*Publication)(nil), "Publication")
	golang_proto.RegisterType((*Publication)(nil), "Publication")
	proto.RegisterType((*Entry)(nil), "Entry")
	golang_proto.RegisterType((*Entry)(nil), "Entry")
	proto.RegisterType((*Subscription)(nil), "Subscription")
	golang_proto.RegisterType((*Subscription)(nil), "Subscription")
	proto.RegisterType((*Notification)(nil), "Notification")
	golang_proto.RegisterType((*Notification)(nil), "Notification")
	proto.RegisterType((*Sub)(nil), "Sub")
	golang_proto.RegisterType((*Sub)(nil), "Sub")
	proto.RegisterType((*Acked)(nil), "Acked")
	golang_proto.RegisterType((*Acked)(nil), "Acked")
	proto.RegisterType((*ApplyCommands)(nil), "ApplyCommands")
	golang_proto.RegisterType((*ApplyCommands)(nil), "ApplyCommands")
	proto.RegisterType((*Command)(nil), "Command")
	golang_proto.RegisterType((*Command)(nil), "Command")
	proto.RegisterType((*Server)(nil), "Server")
	golang_proto.RegisterType((*Server)(nil), "Server")
	proto.RegisterType((*Success)(nil), "Success")
	golang_proto.RegisterType((*Success)(nil), "Success")
	proto.RegisterType((*String)(nil), "String")
	golang_proto.RegisterType((*String)(nil), "String")
	proto.RegisterType((*Strings)(nil), "Strings")
	golang_proto.RegisterType((*Strings)(nil), "Strings")
	proto.RegisterType((*StringMap)(nil), "StringMap")
	golang_proto.RegisterType((*StringMap)(nil), "StringMap")
	proto.RegisterType((*Void)(nil), "Void")
	golang_proto.RegisterType((*Void)(nil), "Void")
	proto.RegisterEnum("DistributionStrategy", DistributionStrategy_name, DistributionStrategy_value)
	golang_proto.RegisterEnum("DistributionStrategy", DistributionStrategy_name, DistributionStrategy_value)
	proto.RegisterEnum("DeliveryStrategy", DeliveryStrategy_name, DeliveryStrategy_value)
	golang_proto.RegisterEnum("DeliveryStrategy", DeliveryStrategy_name, DeliveryStrategy_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Transit service

type TransitClient interface {
	// Ping tests server is alive.
	Ping(ctx context.Context, in *Pong, opts ...grpc.CallOption) (*Pong, error)
	// Publish takes a message entry and returns the published message id.
	Publish(ctx context.Context, in *Entry, opts ...grpc.CallOption) (*Publication, error)
	// Subscribe takes topic and group details and returns a subscription stream.
	Subscribe(ctx context.Context, in *Subscription, opts ...grpc.CallOption) (Transit_SubscribeClient, error)
	// Ack acknowledges the successful receipt and processing of a message id.
	// Acknowledging a message allows you to receive a new message.
	Ack(ctx context.Context, in *Sub, opts ...grpc.CallOption) (*Acked, error)
	// ClusterApply is for applying a set of transformation commands to the cluster's state.
	ClusterApply(ctx context.Context, in *ApplyCommands, opts ...grpc.CallOption) (*Success, error)
	// ClusterGetKeys returns the state values for a given set of cluster keys.
	ClusterGetKeys(ctx context.Context, in *Strings, opts ...grpc.CallOption) (*StringMap, error)
	// ClusterList returns a list of keys and values, with the provided prefix from the cluster.
	ClusterList(ctx context.Context, in *String, opts ...grpc.CallOption) (*StringMap, error)
	// ClusterJoin makes the current leader server perform a join with the given server.
	ClusterJoin(ctx context.Context, in *Server, opts ...grpc.CallOption) (*Success, error)
	// ClusterLeader returns the gRPC address of the current cluster leader.
	ClusterLeader(ctx context.Context, in *Void, opts ...grpc.CallOption) (*String, error)
}

type transitClient struct {
	cc *grpc.ClientConn
}

func NewTransitClient(cc *grpc.ClientConn) TransitClient {
	return &transitClient{cc}
}

func (c *transitClient) Ping(ctx context.Context, in *Pong, opts ...grpc.CallOption) (*Pong, error) {
	out := new(Pong)
	err := grpc.Invoke(ctx, "/Transit/Ping", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transitClient) Publish(ctx context.Context, in *Entry, opts ...grpc.CallOption) (*Publication, error) {
	out := new(Publication)
	err := grpc.Invoke(ctx, "/Transit/Publish", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transitClient) Subscribe(ctx context.Context, in *Subscription, opts ...grpc.CallOption) (Transit_SubscribeClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Transit_serviceDesc.Streams[0], c.cc, "/Transit/Subscribe", opts...)
	if err != nil {
		return nil, err
	}
	x := &transitSubscribeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Transit_SubscribeClient interface {
	Recv() (*Notification, error)
	grpc.ClientStream
}

type transitSubscribeClient struct {
	grpc.ClientStream
}

func (x *transitSubscribeClient) Recv() (*Notification, error) {
	m := new(Notification)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *transitClient) Ack(ctx context.Context, in *Sub, opts ...grpc.CallOption) (*Acked, error) {
	out := new(Acked)
	err := grpc.Invoke(ctx, "/Transit/Ack", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transitClient) ClusterApply(ctx context.Context, in *ApplyCommands, opts ...grpc.CallOption) (*Success, error) {
	out := new(Success)
	err := grpc.Invoke(ctx, "/Transit/ClusterApply", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transitClient) ClusterGetKeys(ctx context.Context, in *Strings, opts ...grpc.CallOption) (*StringMap, error) {
	out := new(StringMap)
	err := grpc.Invoke(ctx, "/Transit/ClusterGetKeys", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transitClient) ClusterList(ctx context.Context, in *String, opts ...grpc.CallOption) (*StringMap, error) {
	out := new(StringMap)
	err := grpc.Invoke(ctx, "/Transit/ClusterList", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transitClient) ClusterJoin(ctx context.Context, in *Server, opts ...grpc.CallOption) (*Success, error) {
	out := new(Success)
	err := grpc.Invoke(ctx, "/Transit/ClusterJoin", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transitClient) ClusterLeader(ctx context.Context, in *Void, opts ...grpc.CallOption) (*String, error) {
	out := new(String)
	err := grpc.Invoke(ctx, "/Transit/ClusterLeader", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Transit service

type TransitServer interface {
	// Ping tests server is alive.
	Ping(context.Context, *Pong) (*Pong, error)
	// Publish takes a message entry and returns the published message id.
	Publish(context.Context, *Entry) (*Publication, error)
	// Subscribe takes topic and group details and returns a subscription stream.
	Subscribe(*Subscription, Transit_SubscribeServer) error
	// Ack acknowledges the successful receipt and processing of a message id.
	// Acknowledging a message allows you to receive a new message.
	Ack(context.Context, *Sub) (*Acked, error)
	// ClusterApply is for applying a set of transformation commands to the cluster's state.
	ClusterApply(context.Context, *ApplyCommands) (*Success, error)
	// ClusterGetKeys returns the state values for a given set of cluster keys.
	ClusterGetKeys(context.Context, *Strings) (*StringMap, error)
	// ClusterList returns a list of keys and values, with the provided prefix from the cluster.
	ClusterList(context.Context, *String) (*StringMap, error)
	// ClusterJoin makes the current leader server perform a join with the given server.
	ClusterJoin(context.Context, *Server) (*Success, error)
	// ClusterLeader returns the gRPC address of the current cluster leader.
	ClusterLeader(context.Context, *Void) (*String, error)
}

func RegisterTransitServer(s *grpc.Server, srv TransitServer) {
	s.RegisterService(&_Transit_serviceDesc, srv)
}

func _Transit_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Pong)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransitServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Transit/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransitServer).Ping(ctx, req.(*Pong))
	}
	return interceptor(ctx, in, info, handler)
}

func _Transit_Publish_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Entry)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransitServer).Publish(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Transit/Publish",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransitServer).Publish(ctx, req.(*Entry))
	}
	return interceptor(ctx, in, info, handler)
}

func _Transit_Subscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Subscription)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TransitServer).Subscribe(m, &transitSubscribeServer{stream})
}

type Transit_SubscribeServer interface {
	Send(*Notification) error
	grpc.ServerStream
}

type transitSubscribeServer struct {
	grpc.ServerStream
}

func (x *transitSubscribeServer) Send(m *Notification) error {
	return x.ServerStream.SendMsg(m)
}

func _Transit_Ack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Sub)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransitServer).Ack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Transit/Ack",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransitServer).Ack(ctx, req.(*Sub))
	}
	return interceptor(ctx, in, info, handler)
}

func _Transit_ClusterApply_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApplyCommands)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransitServer).ClusterApply(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Transit/ClusterApply",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransitServer).ClusterApply(ctx, req.(*ApplyCommands))
	}
	return interceptor(ctx, in, info, handler)
}

func _Transit_ClusterGetKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Strings)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransitServer).ClusterGetKeys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Transit/ClusterGetKeys",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransitServer).ClusterGetKeys(ctx, req.(*Strings))
	}
	return interceptor(ctx, in, info, handler)
}

func _Transit_ClusterList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(String)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransitServer).ClusterList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Transit/ClusterList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransitServer).ClusterList(ctx, req.(*String))
	}
	return interceptor(ctx, in, info, handler)
}

func _Transit_ClusterJoin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Server)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransitServer).ClusterJoin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Transit/ClusterJoin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransitServer).ClusterJoin(ctx, req.(*Server))
	}
	return interceptor(ctx, in, info, handler)
}

func _Transit_ClusterLeader_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransitServer).ClusterLeader(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Transit/ClusterLeader",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransitServer).ClusterLeader(ctx, req.(*Void))
	}
	return interceptor(ctx, in, info, handler)
}

var _Transit_serviceDesc = grpc.ServiceDesc{
	ServiceName: "Transit",
	HandlerType: (*TransitServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Ping",
			Handler:    _Transit_Ping_Handler,
		},
		{
			MethodName: "Publish",
			Handler:    _Transit_Publish_Handler,
		},
		{
			MethodName: "Ack",
			Handler:    _Transit_Ack_Handler,
		},
		{
			MethodName: "ClusterApply",
			Handler:    _Transit_ClusterApply_Handler,
		},
		{
			MethodName: "ClusterGetKeys",
			Handler:    _Transit_ClusterGetKeys_Handler,
		},
		{
			MethodName: "ClusterList",
			Handler:    _Transit_ClusterList_Handler,
		},
		{
			MethodName: "ClusterJoin",
			Handler:    _Transit_ClusterJoin_Handler,
		},
		{
			MethodName: "ClusterLeader",
			Handler:    _Transit_ClusterLeader_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Subscribe",
			Handler:       _Transit_Subscribe_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "transit.proto",
}

func init() { proto.RegisterFile("transit.proto", fileDescriptorTransit) }
func init() { golang_proto.RegisterFile("transit.proto", fileDescriptorTransit) }

var fileDescriptorTransit = []byte{
	// 1247 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x56, 0x5f, 0x6f, 0xdc, 0x44,
	0x10, 0x8f, 0xef, 0xff, 0xcd, 0x25, 0xe1, 0xba, 0xa4, 0xc1, 0x3d, 0x42, 0xe2, 0xb8, 0x79, 0xb8,
	0x9e, 0x88, 0xdd, 0x1e, 0xa2, 0xb4, 0xa9, 0x84, 0xb8, 0x34, 0xa8, 0x2a, 0x6d, 0x51, 0xf1, 0xa1,
	0x82, 0xfa, 0x52, 0xf9, 0xec, 0x89, 0xbb, 0x8a, 0xcf, 0x6b, 0x76, 0xd7, 0xd7, 0x9e, 0xaa, 0x22,
	0xc1, 0x47, 0x80, 0x2f, 0xc4, 0x47, 0x40, 0xea, 0x3b, 0x95, 0x0a, 0x5f, 0x81, 0x77, 0xb4, 0x6b,
	0xfb, 0x72, 0x29, 0x11, 0x52, 0x79, 0xf2, 0xfc, 0x66, 0x7e, 0x33, 0x9e, 0x99, 0x9d, 0xf1, 0x1a,
	0xd6, 0x24, 0xf7, 0x13, 0x41, 0xa5, 0x93, 0x72, 0x26, 0x59, 0xef, 0x52, 0xc4, 0x58, 0x14, 0xa3,
	0xab, 0xd1, 0x24, 0x3b, 0x76, 0xfd, 0x64, 0x5e, 0x98, 0xb6, 0x0a, 0x93, 0x9f, 0x52, 0xd7, 0x4f,
	0x12, 0x26, 0x7d, 0x49, 0x59, 0x22, 0x0a, 0xeb, 0xc7, 0xfa, 0x11, 0xec, 0x47, 0x98, 0xec, 0x8b,
	0x67, 0x7e, 0x14, 0x21, 0x77, 0x59, 0xaa, 0x19, 0xe7, 0xb0, 0xf7, 0x23, 0x2a, 0x9f, 0x66, 0x13,
	0x27, 0x60, 0x53, 0x37, 0x62, 0x11, 0x3b, 0x7d, 0x9f, 0x42, 0x1a, 0x68, 0xa9, 0xa0, 0x5f, 0x5f,
	0xa2, 0x4f, 0x9f, 0x51, 0x79, 0xc2, 0x9e, 0xb9, 0x11, 0xdb, 0xd7, 0xc6, 0xfd, 0x99, 0x1f, 0xd3,
	0xd0, 0x97, 0x8c, 0x0b, 0x77, 0x21, 0xe6, 0x7e, 0x36, 0x87, 0xda, 0x43, 0x96, 0x44, 0xe4, 0x06,
	0x54, 0x68, 0x68, 0x1a, 0x96, 0xd1, 0xaf, 0x1d, 0xf6, 0xdf, 0xfc, 0xb1, 0x53, 0xb9, 0x7b, 0xf4,
	0xe6, 0xf5, 0xce, 0x76, 0x77, 0x65, 0xd0, 0xbb, 0x7b, 0x64, 0x4d, 0x33, 0x21, 0x2d, 0xdf, 0x4a,
	0x99, 0xa0, 0x92, 0xce, 0xd0, 0xa2, 0x89, 0xc4, 0x08, 0xb9, 0x57, 0xa1, 0x21, 0xd9, 0x84, 0x46,
	0x8c, 0x7e, 0x88, 0xdc, 0xac, 0x58, 0x46, 0xbf, 0xed, 0x15, 0x88, 0x98, 0xd0, 0x54, 0x12, 0x4d,
	0x22, 0xb3, 0x6a, 0x19, 0xfd, 0x96, 0x57, 0x42, 0xfb, 0x0e, 0x74, 0x1e, 0x66, 0x93, 0x98, 0x06,
	0xba, 0xe0, 0xff, 0xff, 0x6a, 0xfb, 0xf7, 0x0a, 0xd4, 0xbf, 0x4c, 0x24, 0x9f, 0x93, 0xcd, 0xa5,
	0x18, 0x8d, 0x3c, 0x86, 0x4e, 0xee, 0x3a, 0xd4, 0x25, 0x4b, 0x69, 0x60, 0xd6, 0x55, 0x6e, 0x87,
	0xd6, 0x9b, 0xd7, 0x3b, 0x5b, 0x03, 0x73, 0x64, 0x69, 0x65, 0x1e, 0x7b, 0x82, 0x96, 0xc8, 0xd2,
	0x34, 0xa6, 0x18, 0x7e, 0x6f, 0x78, 0x39, 0x9d, 0x74, 0xa1, 0x1a, 0x33, 0x69, 0x36, 0x74, 0x45,
	0x4a, 0x24, 0x3d, 0x68, 0xd1, 0x10, 0x13, 0x49, 0xe5, 0xdc, 0x6c, 0x6a, 0xf5, 0x02, 0x13, 0x07,
	0x9a, 0x53, 0x14, 0xc2, 0x8f, 0xd0, 0x04, 0xcb, 0xe8, 0x77, 0x86, 0x1b, 0x4e, 0x3e, 0x09, 0x4e,
	0x79, 0x68, 0xce, 0x28, 0x99, 0x7b, 0x25, 0x89, 0x7c, 0x04, 0x90, 0x30, 0xf9, 0x64, 0x82, 0xc7,
	0x8c, 0xa3, 0xb9, 0xa1, 0xb2, 0xf6, 0xda, 0x09, 0x93, 0x87, 0x5a, 0x41, 0x3e, 0x04, 0x05, 0x9e,
	0xf8, 0xc7, 0x12, 0xb9, 0x79, 0x51, 0x5b, 0x5b, 0x09, 0x93, 0x23, 0x85, 0xc9, 0x1e, 0xd4, 0xa6,
	0x28, 0x7d, 0xf3, 0xb1, 0x55, 0xed, 0x77, 0x86, 0x5d, 0x47, 0xd7, 0xef, 0x3c, 0x40, 0xe9, 0x6b,
	0xc9, 0xd3, 0xd6, 0xde, 0x67, 0xd0, 0x5e, 0xa8, 0x54, 0x31, 0x27, 0x38, 0xd7, 0xdd, 0x69, 0x7b,
	0x4a, 0x24, 0x1b, 0x50, 0x9f, 0xf9, 0x71, 0x86, 0xc5, 0x91, 0xe5, 0xe0, 0xa0, 0x72, 0xc3, 0xb0,
	0xff, 0x36, 0x60, 0x75, 0x9c, 0x4d, 0x44, 0xc0, 0xa9, 0x1e, 0x4d, 0x75, 0xbc, 0x29, 0xc7, 0x63,
	0xfa, 0xbc, 0xf0, 0x2f, 0x90, 0x0a, 0x11, 0x71, 0x96, 0xa5, 0x65, 0x08, 0x0d, 0xc8, 0x36, 0x80,
	0x1f, 0xc7, 0x4c, 0x4e, 0x31, 0x91, 0xc2, 0x04, 0xab, 0xda, 0x6f, 0x7b, 0x4b, 0x1a, 0xe5, 0x15,
	0x62, 0xec, 0xcf, 0x8b, 0xa2, 0x73, 0x40, 0x3e, 0x80, 0xe6, 0xd4, 0x7f, 0xfe, 0x44, 0xf5, 0x2f,
	0x2f, 0xb7, 0x31, 0xf5, 0x9f, 0x8f, 0x22, 0x24, 0x37, 0x61, 0x35, 0xa4, 0x42, 0x72, 0x3a, 0xc9,
	0x54, 0x32, 0xe6, 0xb6, 0x65, 0xf4, 0xd7, 0x87, 0x17, 0x9d, 0xa3, 0x25, 0xe5, 0x58, 0x72, 0x5f,
	0x62, 0x34, 0xf7, 0xce, 0x50, 0xc9, 0x3e, 0xb4, 0x42, 0x8c, 0xe9, 0x0c, 0xf9, 0xdc, 0xdc, 0xd1,
	0x6e, 0x17, 0x9c, 0xa3, 0x42, 0xb1, 0x70, 0x59, 0x50, 0xec, 0x23, 0x58, 0xfd, 0x9a, 0x49, 0x7a,
	0x5c, 0x0e, 0xe5, 0x26, 0x54, 0x45, 0x36, 0xd1, 0x35, 0x77, 0x86, 0x35, 0x67, 0x9c, 0x4d, 0x3c,
	0xa5, 0x20, 0x5b, 0x50, 0x47, 0xd5, 0x54, 0x5d, 0x76, 0x67, 0xd8, 0xc8, 0xfb, 0xef, 0xe5, 0x4a,
	0xfb, 0x1e, 0x54, 0xc7, 0xd9, 0xe4, 0x1d, 0x7b, 0x96, 0xcf, 0x6e, 0xf5, 0xed, 0xd9, 0xb5, 0x77,
	0xa1, 0x3e, 0x0a, 0x4e, 0x30, 0x54, 0x9b, 0x24, 0xb2, 0x20, 0x40, 0x21, 0x74, 0xbc, 0x96, 0x57,
	0x42, 0xfb, 0x53, 0x58, 0x1b, 0xa5, 0x69, 0x3c, 0xbf, 0xcd, 0xa6, 0x53, 0x3f, 0x09, 0x05, 0xd9,
	0x83, 0x56, 0x50, 0xc8, 0xa6, 0xa1, 0x27, 0xa4, 0xe5, 0x14, 0x46, 0x6f, 0x61, 0xb1, 0x7f, 0x32,
	0xa0, 0x59, 0x68, 0xc9, 0x16, 0xb4, 0x59, 0x8a, 0x5c, 0x57, 0x5d, 0xa4, 0x7b, 0xaa, 0x28, 0x47,
	0xa7, 0x72, 0xce, 0xe8, 0x54, 0x97, 0x46, 0x47, 0xa5, 0x18, 0xb0, 0x69, 0xea, 0x73, 0x34, 0x6b,
	0x5a, 0x5f, 0x42, 0xd5, 0x8b, 0x19, 0x72, 0x91, 0x89, 0x7c, 0x05, 0xbd, 0x02, 0xd9, 0x07, 0xd0,
	0x18, 0x23, 0x9f, 0x21, 0x5f, 0xda, 0xdd, 0xf6, 0x99, 0xdd, 0x35, 0xa1, 0xe9, 0x87, 0x21, 0x57,
	0x65, 0xe7, 0xef, 0x2f, 0xa1, 0x7d, 0x13, 0x9a, 0xe3, 0xbc, 0x03, 0x8b, 0xde, 0x60, 0x78, 0xa6,
	0x37, 0x18, 0xaa, 0x44, 0x91, 0x73, 0x56, 0x7e, 0x96, 0x72, 0x60, 0x6f, 0x43, 0x63, 0x2c, 0x39,
	0x4d, 0xa2, 0xd3, 0x42, 0x8c, 0xa5, 0x42, 0xec, 0x5d, 0x68, 0xe6, 0x76, 0xa1, 0x33, 0x57, 0xba,
	0xbc, 0x93, 0x2a, 0x73, 0x8d, 0xec, 0x19, 0xb4, 0x73, 0xca, 0x03, 0x3f, 0x25, 0xce, 0x19, 0x52,
	0x67, 0xb8, 0xe9, 0x2c, 0x6c, 0xce, 0x23, 0x6d, 0xc8, 0x07, 0xa4, 0x60, 0xf5, 0x6e, 0x42, 0x67,
	0x49, 0xfd, 0x4e, 0xab, 0xd9, 0x80, 0xda, 0x23, 0x46, 0xc3, 0xc1, 0x21, 0x6c, 0x9c, 0x37, 0xff,
	0x64, 0x0d, 0xda, 0x23, 0x3e, 0xa1, 0x92, 0xfb, 0x7c, 0xde, 0x5d, 0x51, 0xd0, 0xc3, 0x1f, 0x32,
	0x14, 0x12, 0xc3, 0xae, 0x41, 0x56, 0xa1, 0x35, 0x12, 0x82, 0x46, 0x09, 0x86, 0xdd, 0xca, 0xe0,
	0x1b, 0xe8, 0xbe, 0xbd, 0x0c, 0x64, 0x1d, 0xe0, 0x36, 0x4b, 0x82, 0x8c, 0x73, 0x4c, 0x64, 0x77,
	0x85, 0xb4, 0xa0, 0x76, 0xc4, 0x59, 0xda, 0x35, 0x48, 0x07, 0x9a, 0x1e, 0xa6, 0xb1, 0x1f, 0x60,
	0xb7, 0x42, 0x00, 0x1a, 0x77, 0xa3, 0x84, 0x71, 0xec, 0x56, 0x95, 0x3c, 0x46, 0x4e, 0xfd, 0xb8,
	0x5b, 0x1b, 0xbe, 0xaa, 0x42, 0xf3, 0xdb, 0xfc, 0xa6, 0x24, 0x2e, 0xd4, 0x1e, 0xaa, 0x1e, 0xd7,
	0x1d, 0x75, 0xb9, 0xf4, 0xf2, 0x87, 0x7d, 0xe9, 0xe7, 0x57, 0x7f, 0xfd, 0x5a, 0x79, 0x9f, 0x5c,
	0xd0, 0x17, 0xe4, 0xec, 0x9a, 0x9b, 0xd2, 0x24, 0x72, 0x5f, 0xd0, 0xf0, 0x25, 0xb9, 0x05, 0x4d,
	0x7d, 0x25, 0x88, 0xa7, 0xa4, 0x58, 0xa9, 0xde, 0xaa, 0xb3, 0x74, 0x49, 0xd8, 0x3d, 0xed, 0xbb,
	0x61, 0xbf, 0xb7, 0xf0, 0xcd, 0xe9, 0x07, 0xc6, 0x80, 0x7c, 0x07, 0xed, 0xe2, 0x93, 0x35, 0x41,
	0xb2, 0xe6, 0x2c, 0x7f, 0xbe, 0x7a, 0x6b, 0xce, 0xf2, 0x5a, 0xdb, 0x03, 0x1d, 0x66, 0x8f, 0xd8,
	0x65, 0x18, 0x51, 0x3a, 0xba, 0x2f, 0xf2, 0x25, 0x7d, 0xe9, 0xbe, 0xd0, 0x6b, 0xf9, 0xf2, 0xaa,
	0x41, 0x3e, 0x87, 0xea, 0x28, 0x38, 0x21, 0x7a, 0xfd, 0x7b, 0x0d, 0x47, 0x6f, 0xa3, 0x7d, 0x45,
	0x87, 0xb8, 0x4c, 0x76, 0xcb, 0x10, 0x7e, 0x70, 0xf2, 0x2f, 0xe7, 0xbc, 0xaa, 0x01, 0xac, 0xde,
	0x8e, 0x33, 0x21, 0x91, 0xeb, 0x2d, 0x25, 0xeb, 0xce, 0x99, 0x6d, 0xed, 0xb5, 0x9c, 0x62, 0x8c,
	0xed, 0x15, 0xd2, 0x87, 0xf5, 0x82, 0x7b, 0x07, 0xe5, 0x3d, 0x9c, 0x0b, 0xd2, 0x2a, 0x46, 0x49,
	0xf4, 0xe0, 0x74, 0xa8, 0xec, 0x15, 0xb2, 0x07, 0x9d, 0x82, 0x79, 0x9f, 0x0a, 0x49, 0x9a, 0x85,
	0xf1, 0x2d, 0x96, 0xbd, 0x60, 0x7d, 0xc5, 0x68, 0xa2, 0x58, 0x7a, 0xdb, 0xce, 0xbc, 0x73, 0x17,
	0xd6, 0xca, 0x48, 0xf9, 0x9d, 0x5d, 0x77, 0xd4, 0x84, 0xf5, 0xca, 0x90, 0xf6, 0xca, 0xe1, 0x8f,
	0xbf, 0x8c, 0xee, 0x93, 0xfa, 0xb0, 0x7a, 0xcd, 0xb9, 0x3a, 0x30, 0x2a, 0xfc, 0x0b, 0xb8, 0x54,
	0x9c, 0xb1, 0x25, 0x74, 0x3c, 0x8b, 0xa3, 0xbe, 0x9a, 0x19, 0x9f, 0x93, 0xcb, 0x4f, 0xa5, 0x4c,
	0xc5, 0x81, 0xeb, 0x2e, 0xfd, 0x8b, 0x24, 0x18, 0x8a, 0x80, 0x85, 0xe8, 0x16, 0x3f, 0x51, 0xbf,
	0xfd, 0xb9, 0x6d, 0x3c, 0xbe, 0xf2, 0x1f, 0x84, 0xfc, 0x3f, 0xe7, 0x56, 0x81, 0x26, 0x0d, 0x0d,
	0x3f, 0xf9, 0x27, 0x00, 0x00, 0xff, 0xff, 0xa2, 0xe9, 0x5e, 0x1e, 0x85, 0x09, 0x00, 0x00,
}
